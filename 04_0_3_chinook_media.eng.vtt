WEBVTT

00:00:01.046 --> 00:00:02.068
what do we see here?

00:00:02.093 --> 00:00:05.653
so for the question that was asked

00:00:12.262 --> 00:00:15.743
so for each album, give 
the 2 longest tracks

00:00:15.929 --> 00:00:17.196
we are going to search

00:00:18.043 --> 00:00:20.376
for the best performing query

00:00:20.777 --> 00:00:22.677
So that means

00:00:22.923 --> 00:00:25.089
for that first solution
that we have there

00:00:26.629 --> 00:00:28.962
we look at this cost

00:00:28.996 --> 00:00:30.185
So then you actually see

00:00:30.346 --> 00:00:34.009
If you have to summarise it in a number
you always look at the top line

00:00:34.042 --> 00:00:36.453
there were a number of students who 
asked that earlier.

00:00:36.630 --> 00:00:39.518
So the top line gives
the summary of the whole query plan

00:00:39.685 --> 00:00:44.296
The query plan is what the planner/
the opimizer has decided internally from

00:00:44.318 --> 00:00:49.883
with the hardware &amp; memory that I have
with what I know of the table

00:00:50.038 --> 00:00:54.293
I think this is the best way to 
execute this query

00:00:54.436 --> 00:00:56.122
so he describes that here

00:00:56.581 --> 00:00:58.871
the most important number here is 
the last number

00:00:59.044 --> 00:01:01.658
So the 5700 means

00:01:01.892 --> 00:01:04.208
That is the cost to show all data

00:01:04.472 --> 00:01:10.115
and the 16 is the cost of showing 
the first row

00:01:10.527 --> 00:01:12.911
there were people there earlier
so that is the cost

00:01:12.970 --> 00:01:15.665
You can only compare cost prices
on the same database

00:01:15.709 --> 00:01:19.582
because they also depend on parameters 
that you can set on your database

00:01:20.287 --> 00:01:22.371
so then of course you go and look at it like
so yeah

00:01:23.194 --> 00:01:25.510
I also want to show the time

00:01:25.699 --> 00:01:29.455
who else knows the option that
will actually run that query?

00:01:29.691 --> 00:01:32.018
that will also show the time
with that explain?

00:01:35.810 --> 00:01:38.048
yes indeed Arthur
analyze

00:01:40.706 --> 00:01:43.522
So then you get an idea of the time

00:01:43.696 --> 00:01:47.534
what we see here is that time 
is actually quite fast

00:01:47.674 --> 00:01:50.234
so that's 11 milliseconds here.

00:01:51.368 --> 00:01:53.391
I think everything under...

00:01:55.054 --> 00:02:00.304
our eyes work for example if you watch
film than 30 frames per second

00:02:01.803 --> 00:02:06.510
so if it's a thousand milliseconds
we divide that by 30

00:02:07.050 --> 00:02:08.750
and even 20 frames I would say

00:02:08.984 --> 00:02:12.086
anything under 50 milliseconds is actually
to our eyes.

00:02:12.115 --> 00:02:14.271
so then the result is 
still very fast.

00:02:14.296 --> 00:02:16.363
all that is below 50 milliseconds

00:02:16.388 --> 00:02:19.314
so that query is acceptable with
the data that is in there.

00:02:19.436 --> 00:02:22.861
It's not like it says 
"you've got an optimisation problem here".

00:02:25.142 --> 00:02:26.314
what do we see here?

00:02:26.778 --> 00:02:28.876
we see here for example
that the planner

00:02:29.151 --> 00:02:34.238
has 0.2 milliseconds rounded off
and the effective execution is

00:02:34.367 --> 00:02:38.161
those 11 milliseconds so those add up to
12 milliseconds approximately.

00:02:39.030 --> 00:02:40.920
So that's a query that is efficient enough

00:02:41.001 --> 00:02:43.901
but we can check
are there any other options?

00:02:47.145 --> 00:02:50.983
So then we are going to look
for another option.

00:02:53.861 --> 00:02:54.861
let's see

00:03:01.633 --> 00:03:03.454
So this was with a lateral

00:03:03.699 --> 00:03:06.302
This is with a...
without lateral

00:03:06.387 --> 00:03:08.243
we are going to try that one

00:03:09.449 --> 00:03:10.449
let's have a look

00:03:16.880 --> 00:03:17.880
yes...

00:03:18.635 --> 00:03:19.635
now...

00:03:19.911 --> 00:03:23.816
If I'm lazy and I want to know quickly
whether this query is the right query

00:03:24.092 --> 00:03:25.297
how could I do that?

00:03:25.498 --> 00:03:28.517
so euh.... 
that natural ok

00:03:28.922 --> 00:03:32.383
I see a few things there
there is a counting in the subquery there

00:03:32.853 --> 00:03:34.053
let's see...

00:03:35.739 --> 00:03:38.200
track
so that is this track

00:03:38.494 --> 00:03:39.785
milliseconds

00:03:39.896 --> 00:03:44.930
So there is a count here of how many 
there are who have less miliseconds

00:03:48.568 --> 00:03:51.497
and that should be a maximum of 2
so if I look at it correctly

00:03:52.092 --> 00:03:53.647
what is being counted here?

00:03:54.074 --> 00:03:56.156
if i look at it quickly

00:03:56.500 --> 00:04:00.933
we are counting here how many tracks there are that have
have fewer milliseconds.

00:04:02.687 --> 00:04:05.220
and there may be a maximum of 1

00:04:05.245 --> 00:04:06.298
so what do you think?

00:04:15.997 --> 00:04:19.135
I'll pull up the previous query 
query as well.

00:04:21.943 --> 00:04:25.152
then you see this one here
so there I find a...

00:04:26.115 --> 00:04:27.990
these results for example

00:04:28.067 --> 00:04:31.608
and with the other query I find
something else apparently

00:04:31.656 --> 00:04:33.542
although
let's see

00:04:36.569 --> 00:04:37.569
pom pom pom

00:04:49.488 --> 00:04:52.853
I'll be lazy and assume
that the first query is good

00:04:52.878 --> 00:04:54.148
so what could I do?

00:04:56.133 --> 00:04:58.494
i can see the difference 
of those queries

00:04:58.828 --> 00:05:01.149
so I can, for example 
take that first query

00:05:02.704 --> 00:05:04.983
and I can say
"look..."

00:05:05.867 --> 00:05:06.867
"...accept."

00:05:07.167 --> 00:05:08.645
I can see the difference

00:05:08.975 --> 00:05:13.246
with that other query
the query that was given a short while ago

00:05:13.596 --> 00:05:17.306
so
I'm going to cut and paste that back

00:05:21.695 --> 00:05:24.645
I see I did not share my screen properly
moment

00:05:28.450 --> 00:05:30.188
So we are going to adjust that.

00:05:30.774 --> 00:05:31.774
sorry

00:05:31.833 --> 00:05:33.493
so I said, euh

00:05:34.112 --> 00:05:36.072
I'm going to paste this here in the meantime

00:05:44.034 --> 00:05:46.107
so there was the first query from earlier

00:05:47.218 --> 00:05:50.547
namely the one with the left lateral join

00:05:52.680 --> 00:05:55.610
that gives this result
we have taken

00:05:56.116 --> 00:06:00.156
a certain cost of it
That query was acceptable in terms of performance. 
that was ok

00:06:01.445 --> 00:06:03.584
and then we got a second answer

00:06:03.638 --> 00:06:07.559
namely natural inner join
with a correlated subquery

00:06:08.072 --> 00:06:10.892
which also gives me some results

00:06:11.523 --> 00:06:15.030
but if we analyse this query
what do we see?

00:06:17.579 --> 00:06:21.508
the condition here is: i'm going to count how many
milliseconds less track has

00:06:21.555 --> 00:06:22.735
and this track...

00:06:23.535 --> 00:06:25.747
that refers to the track that comes from here

00:06:25.841 --> 00:06:30.594
and this t
refers to the t that comes from here

00:06:31.011 --> 00:06:33.319
so I am going to count here

00:06:33.344 --> 00:06:37.417
how many tracks there are that actually
have fewer milliseconds

00:06:37.749 --> 00:06:38.879
so that are shorter

00:06:38.904 --> 00:06:44.183
and there may be a maximum of 1
maximum 1

00:06:45.144 --> 00:06:47.901
so I'm counting here how many that are shorter

00:06:47.932 --> 00:06:50.726
And what am I supposed to count?
I have to count here how many are...

00:06:52.953 --> 00:06:55.066
not shorter, but how many are...

00:06:56.658 --> 00:07:02.148
...longer
so that's how you have to adjust this query

00:07:04.176 --> 00:07:05.803
so how could I check that?

00:07:05.879 --> 00:07:09.256
as I was counting out just now
suppose you have those two queries and you're not sure

00:07:09.409 --> 00:07:14.102
you can just, it's a dataset,
you can compare these two datasets by

00:07:14.625 --> 00:07:18.892
pasting the two queries underneath each other
without the order by and by inserting an except

00:07:19.056 --> 00:07:22.304
I want all the data except for the ones 
that are present there, for example

00:07:22.615 --> 00:07:25.286
then I get...
normally I am not allowed to get anything

00:07:25.553 --> 00:07:26.838
If they are the same queries

00:07:26.863 --> 00:07:29.494
and if I turn that around I should normally
get nothing either

00:07:29.519 --> 00:07:31.459
if I swap those two queries here

00:07:32.772 --> 00:07:36.466
but i get a lot of data here
so that is indeed a problem

00:07:37.267 --> 00:07:39.227
So if I just adjust this here

00:07:40.497 --> 00:07:42.468
then you see I get nothing

00:07:42.493 --> 00:07:44.933
so the bigger than/smaller than/equal sign

00:07:46.639 --> 00:07:50.313
so then we go back to this query
that was given first

00:07:50.948 --> 00:07:53.952
so then we have to use a
greater than sign

00:07:54.651 --> 00:07:57.229
and we also want to 
look at the cost of this

00:07:57.477 --> 00:08:00.981
we will also ask 
the execution time at the same time

00:08:01.589 --> 00:08:02.589
and what do we see now?

00:08:10.163 --> 00:08:15.526
i get a cost here of
200 to 211

00:08:16.499 --> 00:08:20.546
I get an execution time of
150 milliseconds

00:08:21.413 --> 00:08:25.772
So that execution time I remember is already more 
because a moment ago it was less than 50 milliseconds.

00:08:25.797 --> 00:08:29.407
But the plan 
might have been different.

00:08:29.489 --> 00:08:31.827
so let's look back at the previous one

00:08:32.190 --> 00:08:37.200
I'm going to zoom out a little bit
that I can show both of them

00:08:37.562 --> 00:08:38.922
so this is the plan

00:08:43.054 --> 00:08:44.220
let's go back a bit

00:08:45.581 --> 00:08:48.618
This was it
with the other plan

00:08:49.566 --> 00:08:50.979
So this one here that executes

00:08:51.004 --> 00:08:55.631
despite the fact that we have a higher cost here
we have a lower execution time here

00:08:57.962 --> 00:09:02.393
and here I have a better cost
because I only go up to 200

00:09:02.418 --> 00:09:04.045
here I am at 5000

00:09:05.317 --> 00:09:06.555
but here i get...

00:09:09.620 --> 00:09:12.247
130 milliseconds where I had 11 here.

00:09:12.994 --> 00:09:16.562
So I find that very interesting.
We don't expect this kind of thing

00:09:16.587 --> 00:09:19.851
what is it that you see here that is strange?
who can tell me?

00:09:20.290 --> 00:09:23.176
so you give solutions
we look into it

00:09:24.671 --> 00:09:27.711
I'm going to try to get them to do one thing again.

00:09:28.778 --> 00:09:29.778
so

00:09:30.797 --> 00:09:34.491
So we have a query where
we have this result

00:09:35.054 --> 00:09:37.785
and we have another query where 
we have this result

00:09:37.810 --> 00:09:40.367
And what's interesting 
to see here?

00:09:49.016 --> 00:09:50.196
what do you notice?

00:09:53.045 --> 00:09:55.452
that may not be obvious to see

00:09:55.626 --> 00:09:58.833
so i'll put it down schematically
on paper

00:10:06.928 --> 00:10:11.355
So with the first query we have 
a cost of 211

00:10:12.477 --> 00:10:18.668
and an execution time of
130 milliseconds

00:10:19.158 --> 00:10:26.589
And for the other query we have 
a cost of 5701 and 11 milliseconds.

00:10:30.612 --> 00:10:35.191
Yes Ruben indeed so it might help
what you say there

00:10:35.397 --> 00:10:39.637
So if I could just...
oops it's not connected

00:10:45.935 --> 00:10:46.935
now it is

00:10:48.792 --> 00:10:52.805
If I summarise this briefly
we have two queries here

00:10:53.120 --> 00:10:56.109
One query has a cost of 211
total cost

00:10:56.127 --> 00:10:58.720
The other one is easily greater 
by a factor of 10

00:10:59.384 --> 00:11:05.098
When I look at the times, this query is slower than this one
despite the fact that it has a lower cost