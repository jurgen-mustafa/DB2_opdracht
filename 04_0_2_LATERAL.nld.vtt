WEBVTT

00:00:00.000 --> 00:00:01.722
Lateral joins, ok

00:00:04.270 --> 00:00:05.539
Soms heb je bijvoorbeeld

00:00:05.665 --> 00:00:07.794
Ik toon hier ook af en toe
dingen in die presentaties die je

00:00:07.920 --> 00:00:09.889
Kan gebruiken om ook zelf te experimenteren

00:00:10.270 --> 00:00:11.470
Euhm

00:00:11.697 --> 00:00:12.951
Je hebt snel wat data nodig

00:00:13.274 --> 00:00:14.535
Dus wat doe je hier

00:00:14.663 --> 00:00:17.229
Dit is een functie: generate
series one two three

00:00:17.355 --> 00:00:18.557
Dus 1 2 3

00:00:18.735 --> 00:00:21.221
en ik maak een tijdelijke tabel aan

00:00:21.403 --> 00:00:23.170
Hier staan een aantal dingen, dus dit gaat

00:00:23.374 --> 00:00:25.285
Getallen genereren,
dat heb je wel door denk ik

00:00:25.411 --> 00:00:27.561
Dat is een kolomnaam dat ik daaraan geef

00:00:27.733 --> 00:00:29.185
En ik maak een tijdelijke tabel

00:00:29.683 --> 00:00:31.016
Een tijdelijke tabel is eigenlijk

00:00:31.234 --> 00:00:33.710
In plaats van met een transactie
te werken en rollback te doen

00:00:34.183 --> 00:00:35.383
Euhm

00:00:35.598 --> 00:00:37.113
Een luie manier om te zeggen van

00:00:37.239 --> 00:00:38.372
Ja

00:00:38.498 --> 00:00:41.478
In de achtergrond zitten er
natuurlijk allerlei

00:00:41.635 --> 00:00:44.397
Werkers die in de achtergrond
uw databank in orde houden

00:00:45.000 --> 00:00:46.468
Op het moment dat mijn sessie gedaan is

00:00:46.750 --> 00:00:48.249
En die werkers schieten in actie

00:00:48.415 --> 00:00:50.952
Dan gaan die die tijdelijke tabel
opkuisen en worden die verwijderd

00:00:51.078 --> 00:00:53.807
Dus een beetje zoals de temp
directory op Linux zou je kunnen zeggen

00:00:54.172 --> 00:00:56.481
Dus dat is makkelijk om dingen te testen soms

00:00:57.583 --> 00:00:59.804
Dus we gaan die een keer opvragen.
We zien natuurlijk

00:00:59.930 --> 00:01:03.158
Die nummers 1 2 3 daar dan in verschijnen
in die tijdelijke tabel

00:01:04.251 --> 00:01:05.351
Ok

00:01:06.750 --> 00:01:08.124
Als ik deze query uitvoer he

00:01:08.250 --> 00:01:10.992
De tabel nummers heeft de waardes 1 2 3

00:01:12.033 --> 00:01:14.937
Gaat deze query werken
of is hier een probleem

00:01:19.983 --> 00:01:21.871
Wie ziet er de tabel nummers

00:01:22.014 --> 00:01:23.647
Ik zal hem even terug tonen misschien

00:01:23.808 --> 00:01:25.530
Hij heeft de kolom max_num

00:01:25.967 --> 00:01:27.474
En de waardes 1 2 3

00:01:27.632 --> 00:01:28.949
Dat is de tabel nummers
Dus als je kijkt naar deze query, is
hier een probleem of gaat dat werken?

00:01:34.050 --> 00:01:35.264
Wat denken jullie?

00:01:45.117 --> 00:01:47.188
Misschien in het wat moeilijk
om die vraag te beantwoorden

00:01:47.343 --> 00:01:50.358
Maar begrijp je conceptueel
wat er hier staat in de FROM

00:01:50.484 --> 00:01:52.819
Wat is de eerste stap die
er in de FROM gebeurt

00:01:55.283 --> 00:01:57.333
Da's altijd dezelfde stap,
want er staat een komma

00:01:57.459 --> 00:01:59.069
Dus de eerste stap is een...

00:02:00.899 --> 00:02:03.382
Cross Join, goed Filip! Cross Join

00:02:04.220 --> 00:02:08.183
Niet geëxpliciteerd, dus we spreken
abstract gezien van een carthesisch product

00:02:08.587 --> 00:02:10.087
Die nummers is 1 2 3

00:02:10.350 --> 00:02:12.217
Maar wat staat er in die tweede tabel

00:02:13.617 --> 00:02:15.217
Wat staat daarin

00:02:19.700 --> 00:02:22.017
Zou je conceptueel kunnen denken

00:02:22.395 --> 00:02:24.968
We hebben dat nog niet gezien, maar
conceptueel zou je misschien kunnen denken

00:02:25.094 --> 00:02:27.189
Ik denk dat daar zoiets gaat inkomen

00:02:31.967 --> 00:02:34.536
Die generate_series begint gewoon
met waarde 1

00:02:34.739 --> 00:02:36.571
En die stopt bij waarde max_num

00:02:36.697 --> 00:02:39.101
En max_num was een kolom uit nummers

00:02:40.017 --> 00:02:41.117
Dus

00:02:42.127 --> 00:02:43.630
Een lijst van 1 tot max_num

00:02:43.804 --> 00:02:45.763
Inderdaad Sigfried, maar wat is die max_num?

00:02:46.198 --> 00:02:49.221
Die max_num komt van
nummers, dus wat verwacht je daar

00:02:51.867 --> 00:02:53.160
Zeer goed Jarne, ja

00:02:53.333 --> 00:02:54.666
Dus jij verwacht inderdaad

00:02:54.967 --> 00:02:56.363
Nummers is een keer 1

00:02:57.100 --> 00:03:00.325
De max_num van nummers is een
keer 1, dus ik verwacht een keer (1, 1)

00:03:00.717 --> 00:03:02.900
Nummers is een keer 2

00:03:03.026 --> 00:03:04.216
De volgende rij daarin

00:03:04.342 --> 00:03:07.104
Dus ik verwacht een keer
generate_series van 1 tot 2

00:03:07.551 --> 00:03:08.670
En nummers is een keer 3

00:03:08.796 --> 00:03:11.575
De laatste rij, dus ik verwacht
generate_series van 1 tot 3

00:03:13.300 --> 00:03:16.212
Dit is hetgeen wat je conceptueel
kan denken, dus da's goed

00:03:16.389 --> 00:03:19.768
Dit gaat een probleem geven,
hij gaat zeggen van kijk euhm

00:03:21.458 --> 00:03:23.752
Dat werkt niet, want ik
vind daar mijn max_num

00:03:24.397 --> 00:03:28.340
En hij ziet dat - hij weet - hij beseft van
kijk dat is aanwezig in de tabel nummers

00:03:28.466 --> 00:03:31.976
Maar je kan daar niet naar verwijzen
omdat dat op hetzelfde niveau zit

00:03:32.193 --> 00:03:34.148
Je kan niet op hetzelfde niveau in de FROM

00:03:34.355 --> 00:03:35.561
Dat gaat niet

00:03:35.987 --> 00:03:38.599
Aan wat soort constructie doet
ons dat eigenlijk hier denken

00:03:38.798 --> 00:03:41.377
Met hetgeen wat we in het
eerste semester gezien hebben

00:03:42.233 --> 00:03:44.367
Die max_num die komt van ergens anders

00:03:45.761 --> 00:03:47.729
Dus als je denkt aan
subquerries, aan wat soort

00:03:47.933 --> 00:03:51.658
Dit is geen subquerry, maar aan wat
soort subquerry doet dit jou dan denken?

00:03:56.300 --> 00:03:58.799
Omdat ik hier een afhankelijkheid heb

00:04:02.254 --> 00:04:04.245
Inderdaad Kim, een gecorreleerde subquerry

00:04:04.621 --> 00:04:07.404
Dus we kunnen inderdaad zoiets
doen als gecorreleerde subquerries

00:04:07.530 --> 00:04:09.673
Maar dan moeten we inderdaad dus

00:04:10.194 --> 00:04:11.503
Dit probleempje oplossen

00:04:11.901 --> 00:04:14.124
En dat doen we door het gebruik van lateral

00:04:14.754 --> 00:04:16.747
Dus lateral wanneer dat
we een subquerry of een

00:04:17.133 --> 00:04:18.508
Deel in de tabel in de FROM

00:04:19.134 --> 00:04:22.741
Hebben staan en we willen verwijzen naar
een ander deel in de FROM dat daar voor staat

00:04:22.948 --> 00:04:24.709
Dan gebruiken we lateral

00:04:25.500 --> 00:04:27.697
Om te zeggen lateral - op
hetzelfde niveau als je wil

00:04:28.088 --> 00:04:29.188
Lateraal

00:04:29.889 --> 00:04:32.228
Dus zo kunnen wij eigenlijk
die verwijzingen gaan maken

00:04:32.354 --> 00:04:33.553
Dus die vorige query

00:04:34.933 --> 00:04:36.488
Dit staat meer in detail natuurlijk

00:04:37.185 --> 00:04:38.391
Misschien even opsommen

00:04:39.356 --> 00:04:42.886
Dus je kunt verwijzen naar een eerdere
tabelreferentie - zoals die nummers

00:04:43.012 --> 00:04:46.274
Je kunt verwijzen naar een eerdere subquery
(als er een subquery in de FROM staat)

00:04:46.560 --> 00:04:48.441
Of je kunt verwijzen naar een functie

00:04:48.703 --> 00:04:51.502
Die een set teruggeeft,
een set returning function

00:04:51.628 --> 00:04:53.313
Dus een functie die een
verzameling teruggeeft

00:04:53.654 --> 00:04:55.876
generate_series is daar één voorbeeld van

00:04:59.277 --> 00:05:01.427
In de standaard

00:05:02.183 --> 00:05:05.847
Is het zelfs toegelaten wanneer
er een set returning function staat

00:05:05.973 --> 00:05:08.731
Van dat eventueel weg te laten -
dus had ik dat daar anders gezet

00:05:08.893 --> 00:05:10.875
Was dat geen tabel geweest
die nummers, maar een

00:05:11.130 --> 00:05:13.621
Set returning function, dan
had ik dat ook zo kunnen doen

00:05:14.117 --> 00:05:15.974
Maar ik raad dit laatste stukje

00:05:16.590 --> 00:05:19.391
Niet aan omdat dat wat verwarrend
kan zijn, het is maar dat je dat weet

00:05:19.775 --> 00:05:23.825
Dus als je verwijst op hetzelfde
niveau, zet dan gewoon lateral

00:05:24.465 --> 00:05:27.469
Maar bij set returning functions
kan je het eventueel weglaten

00:05:28.833 --> 00:05:30.682
Dus ik zet hier mijn lateral

00:05:31.248 --> 00:05:36.307
En vanaf dat moment krijg ik inderdaad
de resultaten die Jarne daar voorspeld had

00:05:36.641 --> 00:05:38.829
Dus ik krijg 1 met 1

00:05:39.017 --> 00:05:40.495
2 is nu mijn max_num hier

00:05:40.833 --> 00:05:44.391
Dus ik krijg 1 en 2 bij generate_series
gecombineerd met die twee

00:05:44.664 --> 00:05:46.664
En voor 3 krijg ik 1 2 3

00:05:49.083 --> 00:05:53.305
Zo zie je eigenlijk er is een
afhankelijkheid in mijn FROM die ik gebruik

00:05:56.335 --> 00:05:58.287
Dus hetgeen wat ik net gezegd heb van kijk

00:05:59.000 --> 00:06:01.928
Deze twee querries, omdat het een generate

00:06:02.410 --> 00:06:04.805
Een set generating function is

00:06:05.013 --> 00:06:08.351
Set returning function kan je
inderdaad nog gebruiken, maar goed

00:06:09.194 --> 00:06:10.972
Toon per klant de leeftijd

00:06:11.339 --> 00:06:13.719
Er zijn verschillende
manieren om dit op te lossen

00:06:15.784 --> 00:06:18.014
Je zou dit kunnen doen
met een lateral join nu

00:06:19.947 --> 00:06:23.067
We hebben klanten, en we
berekenen eigenlijk hier per klant

00:06:23.937 --> 00:06:26.230
De leeftijd en we zeggen van kijk euhm

00:06:30.172 --> 00:06:33.989
Dit is natuurlijk een ingewikkelde constructie
om iets wat je normaal eenvoudiger oplost he

00:06:34.115 --> 00:06:36.615
Toon per klant de leeftijd, hoe
zouden jullie dat normaal doen?

00:06:37.633 --> 00:06:41.497
Het is maar gewoon een eerste voorbeeldje
om te zien dat je nog alternatieven hebt

00:07:06.783 --> 00:07:10.399
Ja inderdaad, je gaat dat gewoon
berekenen, ophalen op die manier he

00:07:14.991 --> 00:07:18.670
Omdat we daar - misschien nog
een kleine nota - omdat we daar een

00:07:19.527 --> 00:07:21.185
Join conditie, left join

00:07:21.426 --> 00:07:22.820
Verwacht hij een join conditie

00:07:23.229 --> 00:07:25.625
Je kan eens zelf nadenken

00:07:25.850 --> 00:07:27.382
Wat is dat hier met die join conditie

00:07:27.705 --> 00:07:30.900
Je kan een keer een andere join conditie
proberen en kijken wat er dan gebeurt

00:07:31.319 --> 00:07:33.398
Dus dat kan je misschien een keer uitproberen

00:07:34.713 --> 00:07:35.813
Dus

00:07:35.939 --> 00:07:37.048
Inderdaad

00:07:37.181 --> 00:07:39.269
Ik heb het eigenlijk verklapt:
is die join conditie nodig?

00:07:39.395 --> 00:07:41.517
Er wordt daar eigenlijk een
carthesisch product genomen he

00:07:42.040 --> 00:07:44.332
Dus ik had hier even goed
kunnen zetten: ON true

00:07:44.552 --> 00:07:45.956
Want als je teruggaat

00:07:46.157 --> 00:07:48.728
Er is niemand die de opmerking
gemaakt heeft, maar leeftijd

00:07:48.936 --> 00:07:50.317
En geboortedatum

00:07:50.567 --> 00:07:52.167
En hier toch age

00:07:52.460 --> 00:07:54.621
Had ik hier nog iets anders kunnen zetten?

00:07:56.027 --> 00:07:58.249
Dus eigenlijk gewoonweg, die true hier

00:07:58.720 --> 00:08:02.824
Dat is gewoon omdat een join, per
definitie verwacht een join conditie

00:08:02.950 --> 00:08:04.817
Tenzij dat hier een
cross join staat natuurlijk

00:08:05.336 --> 00:08:06.436
Dus vandaar

00:08:09.832 --> 00:08:11.498
Dit geeft natuurlijk
weer hetzelfde resultaat

00:08:11.624 --> 00:08:13.982
Dat is dan die cross join
die ik eigenlijk gebruik

00:08:16.626 --> 00:08:20.272
Dus, dat carthesisch product
zoals we gezien hebben en euhm

00:08:20.629 --> 00:08:23.493
Jarne eigenlijk in eerste
instantie intuïtief aanvoelde

00:08:25.179 --> 00:08:27.178
Dat is eigenlijk zoals
jullie dat intuïtief aanvoelen

00:08:27.313 --> 00:08:29.767
Vanuit subquerries, vanuit
programmeren met een

00:08:29.919 --> 00:08:31.861
Een lus die afhankelijk is van een andere lus

00:08:32.183 --> 00:08:36.016
Dus eigenlijk kunnen we die
ON true meestal wel toevoegen

00:08:37.772 --> 00:08:39.452
Dus welk soort join

00:08:40.351 --> 00:08:41.462
Ga je nemen

00:08:43.521 --> 00:08:46.165
Dat hangt van jou af he, dus
je hebt hier die cross, die inner

00:08:46.388 --> 00:08:49.060
Die gaan zich hetzelfde gedragen, maar

00:08:51.100 --> 00:08:52.745
Het carthesisch product zelf

00:08:52.871 --> 00:08:54.753
Dat blijft zich dus hetzelfde gedragen

00:08:54.928 --> 00:08:57.274
Nu gebruik jij left of right of full

00:08:57.538 --> 00:09:00.480
Dan gaan er eventueel data
worden aangevuld die ontbraken

00:09:00.606 --> 00:09:02.669
Die eventueel weggefiltert waren

00:09:07.250 --> 00:09:08.836
We kunnen hier eigenlijk gaan kiezen he

00:09:13.493 --> 00:09:16.483
Je kan gaan werken met een cross
join, je kan gaan werken met een inner join

00:09:16.609 --> 00:09:18.513
Of we kunnen dat gaan
opschrijven gewoonweg met

00:09:18.864 --> 00:09:21.209
Rechtstreeks een kommatje daar te zetten

00:09:21.723 --> 00:09:23.269
Dus dat zijn allemaal opties die je hebt

00:09:23.585 --> 00:09:25.291
Die eigenlijk in dit geval

00:09:25.629 --> 00:09:27.105
Zich hetzelfde gaan gedragen

00:09:28.689 --> 00:09:31.589
Nu als we gaan kijken naar dit hier

00:09:32.127 --> 00:09:33.436
Dan hebben we hier iets anders staan

00:09:34.010 --> 00:09:35.690
Kijk er even naar

00:09:51.067 --> 00:09:52.717
Ziet er iemand het verschil?

00:09:53.014 --> 00:09:55.914
Waar dat het verschil gemaakt wordt

00:10:13.200 --> 00:10:16.283
Ik heb gezegd, als we werken met cross join of inner join

00:10:16.550 --> 00:10:18.550
Dat is eigenlijk hetzelfde als het commatje

00:10:19.200 --> 00:10:20.800
Maar hier is er nog iets anders aan de hand

00:10:20.800 --> 00:10:22.800
En als soms mensen denken, ik kan dat toch

00:10:22.800 --> 00:10:24.400
waarom zijn deze dan verschillend

00:10:24.600 --> 00:10:25.960
Deze twee queries

00:10:46.900 --> 00:10:48.900
Je zit daar met een on conditie

00:10:49.267 --> 00:10:51.767
Dus bij de tweede is er nog een on conditie toegevoegd

00:10:51.767 --> 00:10:52.967
Die niet over een gelijkheid gaat

00:10:52.980 --> 00:10:56.730
Als je denkt aan het verband dat hier wordt uitgerekend

00:10:56.800 --> 00:10:58.200
Dus dan verwijzen we hier naar die tabel, k

00:10:58.783 --> 00:11:00.317
Die dingen moeten dus overeenkomen

00:11:00.350 --> 00:11:05.584
Het moet dus over die naam gaan en die geboorte datum die uit k komt

00:11:05.600 --> 00:11:08.450
Hier is dat ook wel zo, maar daar krijg je die filter er nog een bij

00:11:16.767 --> 00:11:18.834
Dus, wat je er dan nog krijgt is van

00:11:20.030 --> 00:11:21.030
Vermijt dit

00:11:22.600 --> 00:11:26.717
Elke right join kan je schrijven als een left join

00:11:26.720 --> 00:11:31.300
Er zijn zelfs databanken, mysql heeft lang geen right outer join gehad

00:11:33.570 --> 00:11:36.033
Je kan dat natuurlijk altijd proberen te herschrijven als een left outer join

00:11:36.330 --> 00:11:38.167
Dus het zelfde met die FULL daar

00:11:38.217 --> 00:11:41.609
Omdat het gedrag inderdaad niet goed gedefinieerd is

00:11:42.500 --> 00:11:44.200
Dus basis gezien kan je zeggen van

00:11:44.250 --> 00:11:49.667
Ik heb hier oftewel cross join die zich gedraagd
zoals een inner join met een gelijkheid

00:11:49.833 --> 00:11:51.867
Zoals de relatie die er is gelegd

00:11:53.017 --> 00:11:57.033
Ik kan hier eventueel een extra join conditie
opgeven die niet gaat om een gelijkheid

00:11:57.817 --> 00:12:01.067
Dan krijg ik een ander soort gedrag,
of ik kan eventueel werken met een outer join

00:12:01.170 --> 00:12:07.717
Een left outer join met eventuele data die niet aanwezig
is in mijn afhankelijk deel

00:12:08.967 --> 00:12:13.367
Om dan toch toe te voegen, uit mijn onspronkelijke
eerst gezette tabel

00:12:18.017 --> 00:12:21.217
Opnieuw dit zou nu vrij snel moeten kunnen gaan

00:12:22.000 --> 00:12:30.100
Ik kan dit snel eenvoudiger zetten zonder dat de lateral daar join nodig is
ik kan die performanter maken

00:12:36.700 --> 00:12:43.633
Wat doet lateral? Lateral zorgt er voor dat die k die er staat
select age k, geboorte datum dat ik die k

00:12:43.770 --> 00:12:48.283
Die er staat komt van klanten, zodat ik de geboorte datum
er van kan opvragen

00:12:48.550 --> 00:12:51.767
Zonder dat woordje lateral wordt de querie niet uitgevoerd

00:12:52.500 --> 00:12:57.317
Die k geboorte datum, ik zie wel dat dat van klanten komt
maar ik kan daar niet naar verwijzen

00:12:58.150 --> 00:13:01.967
Omdat de sql standaard daar gedefinieerd is

00:13:03.900 --> 00:13:08.650
Dus die zorgt eigenlijk voor dat je analoog aan de gecorraleerde subqueries
maar die staan dan op een lager niveau

00:13:09.267 --> 00:13:12.851
En hier kan verwijzen naar iets dat op het zelfde niveau staat

00:13:14.000 --> 00:13:17.300
Dus hoe kon dit eenvoudiger? Dat is daarstraks al gezegd denk ik

00:13:22.700 --> 00:13:24.933
Ik probeer te zien of iedereen wakker is

00:13:36.300 --> 00:13:38.967
Er wordt per klant eigenlijk gewoon de geboorte datum berekend

00:13:39.650 --> 00:13:42.433
De leeftijd van de geboorte datum, dus gewoon de leeftijd eigenlijk

00:13:45.117 --> 00:13:47.217
Maar hoe kan je dit eenvoudiger doen?

00:13:52.033 --> 00:13:54.400
Mischien Adam, wat denk jij?

00:14:05.000 --> 00:14:07.717
Inderdaad Kevin, geen subquarie, maar gewoon in de select zetten

00:14:08.100 --> 00:14:11.350
Dus ster, age k geboorte datum

00:14:15.230 --> 00:14:19.283
Inderdaad Milan, dus dit stukje age k punt geboorte datum zet je in de select

00:14:19.883 --> 00:14:22.967
En dan de rest wat er na het woordje lateral komt schrap je gewoon

00:14:23.867 --> 00:14:25.333
Dus ja, prima

00:14:27.967 --> 00:14:35.867
Oke, er zijn een aantal gevallen waar je zegt van hoe kunnen we nu die lateral joins gaan gebruiken

00:14:36.267 --> 00:14:41.083
Want in de praktijk ga je zien van, je probeert vragingen, 
query opvragingen te beantwoorden

00:14:41.400 --> 00:14:44.350
Wanneer ga ik dat zoal nodig hebben, en als je problemen 
hebt om iets op te lossen

00:14:45.533 --> 00:14:48.083
Wanneer ga je dan aan die lateral denken

00:14:48.317 --> 00:14:53.783
Dus het gaat over normalisatie, dus het gaat over een join
 conditie die moet berekend worden

00:14:54.000 --> 00:14:56.300
Op basis van een colom waar naar verwezen wordt

00:14:56.517 --> 00:15:02.500
Normalisatie bedoel ik mee een gelijk vorming van de totaal som
 van iets dat daar voor berekend is

00:15:02.733 --> 00:15:08.667
Dus, wanneer je eigenlijk subqueries hebt die afhankelijk zijn

00:15:09.450 --> 00:15:13.800
Subqueries waarvan je het resultaat intussen van wil gebruiken
 met afhankelijkheden

00:15:14.683 --> 00:15:18.033
Dus een voorbeeld van normalisatie bijvoorbeeld

00:15:19.517 --> 00:15:22.667
Dus, stel we hebben een tabel die gedenormaliseerd is

00:15:23.067 --> 00:15:26.050
Jullie hebben allemaal technieken van datamodelering gehad

00:15:26.430 --> 00:15:31.183
Dus daar hebben we u leren normaliseren de omgekeerde weg wanneer we tabellen gaan samenvoegen

00:15:31.417 --> 00:15:36.533
Dus alle mogelijke combinatie die volgens de
afhankelijkheden kloppen samen voegen

00:15:36.817 --> 00:15:41.900
Dus gewoon een join tussen twee tabellen eigenlijk,
is een de-normalisatie zou je kunnen zeggen

00:15:44.317 --> 00:15:47.467
Dan kunnen we dat gaan gebruiken bijvoorbeeld

00:15:47.950 --> 00:15:56.283
Dus, laat on zeggen we hebben bijvoorbeeld een gedenormaliseerde
tabel, namelijk zeggen van dit zijn mijn id's

00:15:56.517 --> 00:15:59.317
Die komen overeen met allemaal andere id's

00:16:00.030 --> 00:16:06.083
Ik heb bijvoorbeeld hier de rij 1, 2, 3, 
4, 5, 6 en deze rij

00:16:09.070 --> 00:16:13.517
Dus wat wil dat nu zeggen als je denkt aan hoe ziet deze,
ik ken hem niet meer vanbuiten, ja inderdaad

00:16:13.800 --> 00:16:19.333
Dus dit is gedenormaliseerd, want normaal gezien wat verwacht je
in een genormaliseerde tabel, als in bijvoorbeeld

00:16:19.567 --> 00:16:24.733
Tussentabel zoals jullie het populair noemen is,
hoe zou deze er dan uitzien?

00:16:25.367 --> 00:16:35.833
Dus om te zeggen dat id 1, speler 1 bijvoorbeeld verwijst naar positie 1,
speler 1 verwijst naar positie 2 en speler 1 ook verwijst naar positie 3

00:16:35.983 --> 00:16:37.850
Daar is een verband, daar weten we iets van positie en speler

00:16:39.070 --> 00:16:42.967
Speler 2 verwijst naar positie 4, speler 2 verwijst ook naar positie 5

00:16:43.383 --> 00:16:47.283
Dus hoe werd dit normaal opgeslagen zoals jullie het gezien hebben

00:16:50.070 --> 00:16:54.350
Als we een tabel spelers hebben en een tabel posities met 
daartussen een veel op veel

00:16:57.000 --> 00:17:00.533
Dan krijg ik in de plaats van 3 rijen hier, hoeveel rijen?

00:17:08.030 --> 00:17:12.200
Om bij te houden, het is hier een abstract voorbeeld,
inderdaar Lucas, negen

00:17:12.500 --> 00:17:17.033
1 met 1 gecombineerd, 1 met 2, 1 met 3,
dat zijn dan de eerste 3 rijen

00:17:17.200 --> 00:17:19.367
Dus dit is gedenormaliseerd

00:17:19.967 --> 00:17:23.650
Dus het is ook ambetant om daar een, je kan hier niet zeggen:
het is hier een gelijk aan

00:17:24.200 --> 00:17:26.167
Het is een ambetante join conditie daar

00:17:26.500 --> 00:17:32.517
Dus, wat we gaan doen is kijk euhmmm, 
we gaan is een tabel maken parent

00:17:32.670 --> 00:17:36.133
Dus daar zal die waarde 1, 2, 3

00:17:36.133 --> 00:17:42.200
Oke, en we gaan zeggen, we verwijzen daar naar, 
we zitten met eventuele kinderen

00:17:43.430 --> 00:17:47.033
Een functie die ik nu kan gaan gebruiken bijvoorbeeld
om dit uit elkaar te gaan halen

00:17:47.383 --> 00:17:54.217
Is unnest, dus dat wil zeggen dat wanneer we gedenormaliseerde data hebben, 
ge gaat die misschien op een bepaald moment wel tegen komen

00:17:54.367 --> 00:17:58.917
Ma je zal ondervinden dat het lastig is om daar mee te werken,
dan kan je die terug gaan normaliseren

00:17:59.267 --> 00:18:06.067
En terug gaan vast zetten, en uit elkaar halen met die functie, unnest,
dus een rij zoals daarstraks kunnen we op deze manier omzetten

00:18:06.317 --> 00:18:08.233
Zodat het terug allemaal apparte waarde zijn

00:18:08.950 --> 00:18:10.800
Dus, wat krijg ik dan?

00:18:11.183 --> 00:18:13.683
Ik had die gedenormaliseerde tabel

00:18:14.317 --> 00:18:17.267
En daarin stonden die 1 met 1, 2 ,3

00:18:17.700 --> 00:18:20.550
die 2 met, ik weet het niet vanbuiten, 2, 4 ,5

00:18:22.230 --> 00:18:26.550
Dus die other ids dat was die 1, 2, 3, die rij van 1, 2, 3,
die ga ik hier unnesten

00:18:27.030 --> 00:18:29.133
Dus dat wordt dan 1, 2, 3 onder elkaar

00:18:29.417 --> 00:18:33.350
Dus als ik dat dan ga joinen, krijg ik mooi
deze resultaten

00:18:33.750 --> 00:18:38.200
Dus eigenlijk, hier krijg ik terug mijn genormaliseerde data terug

00:18:41.200 --> 00:18:44.350
Die 9 rijen die dat Lucas ook al voorspeld had daar

00:18:46.450 --> 00:18:48.067
Dus dat is 1 mogelijkheid

00:18:48.170 --> 00:18:53.467
Wat wilt dat zeggen, ik heb die query gedaan,
dat is deze query, om te testen van werkt dit goed

00:18:53.600 --> 00:18:59.400
Ik heb hier de data, dus kan ik hem eigenlijk gaan voorstellen om een manier
dat ze genormaliseerd zijn

00:18:59.500 --> 00:19:04.550
In plaats van op een manier dat ze gedenormaliseerd zijn,
zo zijn ze nu opgeslagen

00:19:04.867 --> 00:19:08.750
Voor mij is het veel intressanter dat ik ze op deze manier op sla

00:19:09.283 --> 00:19:13.783
Dus het enige wat ik dan hoef te doen is, dit is een query,
ik maak van die query een insert statement

00:19:14.167 --> 00:19:18.450
Door er gewoon insert voor te zetten, dus insert in de tabel
die we hebben aangemaakt

00:19:19.050 --> 00:19:22.733
Dus die zetten we dan daar in

00:19:22.800 --> 00:19:25.367
Dus dat is ook iets wat je kan doen, wat ik denk dat je al onder vonden had

00:19:25.750 --> 00:19:29.633
Insert kan je de values gebruiken, insert into tabel, x values

00:19:30.017 --> 00:19:33.517
En dan som je waarde op, maar daar kan even goed een select statement staan

00:19:33.767 --> 00:19:35.850
Bijvoorbeeld om een insert te doen

00:19:38.050 --> 00:19:45.033
Oke, een ander geval, dus we hebben daar het geval gezien van
normalisatie, denormalisatie

00:19:45.383 --> 00:19:50.783
Een join conditie die moet berekend worden op basis van een
colom waar naar verwezen wordt

00:19:52.270 --> 00:19:55.300
Dit kan je ook nog op andere manier oplossen maar dit was zowat 1 voorbeeld

00:19:55.667 --> 00:20:00.683
Beeld u in, je wilt alle mensen weten die een gemeenschappelijke
 letters hebben in hun voornaam

00:20:00.710 --> 00:20:01.570
voorbeeld

00:20:01.909 --> 00:20:05.770
mijn collega, amie en ik, wim daar zit de letter "m" in

00:20:06.056 --> 00:20:08.703
dus we hebben gemeenschappelijke letters in onze voornaam

00:20:09.170 --> 00:20:12.070
bijvoorbeeld ik zie daar staan

00:20:12.603 --> 00:20:14.217
lucas is de laatste hier

00:20:14.497 --> 00:20:17.217
lucas en mijn naam hebben geen gemeenschappelijke letters

00:20:17.390 --> 00:20:18.430
lucas en milan wel

00:20:19.980 --> 00:20:22.620
lucas en kevin ook niet,   bijvoorbeeld

00:20:23.406 --> 00:20:26.713
ik wil mensen tonen die gemeenschappelijke letters hebben in hun voornaam

00:20:29.487 --> 00:20:31.587
daarvoor kunnen we bijvoorbeeld dit gebruiken

00:20:32.513 --> 00:20:35.527
er bestaat een functie zoals daarnest een nest

00:20:35.552 --> 00:20:38.010
zodat we strings kunnen omzetten naar

00:20:38.223 --> 00:20:39.377
aparte karakters

00:20:39.530 --> 00:20:40.457
dat is een eerste stap

00:20:43.097 --> 00:20:45.443
zo kan ik namen en voornamen omzetten

00:20:45.754 --> 00:20:47.054
dus denk ernaen we hebben die functie

00:20:47.400 --> 00:20:49.614
voornamen gaan omzetten naar aparte letters

00:20:51.394 --> 00:20:52.007
oke

00:20:53.654 --> 00:20:55.714
dan zouden we dat eigenlijk kunnen gebruiken

00:20:55.960 --> 00:20:58.167
dan zouden we dit kunnen gebruiken om een naam

00:20:58.293 --> 00:21:00.393
dus zoals daarnet een tabel werd gemaakt

00:21:00.473 --> 00:21:01.987
van enederzijds een rij

00:21:03.280 --> 00:21:04.813
dan de overeenkomstige waarden

00:21:06.277 --> 00:21:07.777
zou je dat hier kunnen doen

00:21:07.843 --> 00:21:09.270
om eigenlijk de namen te gaan combineren

00:21:09.337 --> 00:21:10.577
met al hun aparte letters

00:21:10.863 --> 00:21:12.817
begrijpt iedereen, ik laat hem even staan

00:21:14.100 --> 00:21:14.840
bijvoorbeeld

00:21:14.993 --> 00:21:16.580
beeld u in een tabel klanten staat

00:21:16.600 --> 00:21:17.833
enkel het woord

00:21:17.927 --> 00:21:18.600
arthur

00:21:18.873 --> 00:21:20.153
er is maar een naam

00:21:20.567 --> 00:21:22.360
klant nummer 1 met arthur

00:21:22.857 --> 00:21:24.484
wat wordt hier dan getoond

00:21:25.297 --> 00:21:26.710
wat komt uit deze query

00:21:26.735 --> 00:21:27.317
wie kan dat zeggen

00:21:30.837 --> 00:21:33.297
beeld u in tabel klant heeft maar één rij

00:21:34.123 --> 00:21:36.163
genaamd klant 1 arthur

00:21:52.050 --> 00:21:54.223
zal eerst een andere vraag stellen

00:21:54.417 --> 00:21:56.223
hoeveel rijen gaan hier uit komen

00:21:56.857 --> 00:21:57.823
uit deze query

00:22:05.206 --> 00:22:06.193
een rij

00:22:07.714 --> 00:22:09.340
mensen die nog een ander idee hebben?

00:22:12.287 --> 00:22:13.600
denk eraan daarbinnen

00:22:14.360 --> 00:22:15.454
heb je zoiets als

00:22:15.520 --> 00:22:16.494
een cartesische product

00:22:16.684 --> 00:22:18.684
maar wel met die afhankelijkheid hier vandaan

00:22:18.924 --> 00:22:19.604
dus die

00:22:19.770 --> 00:22:20.657
arthur

00:22:21.070 --> 00:22:23.284
die gaat hie op die "k1.vnaam" komen hee

00:22:24.124 --> 00:22:25.230
inderdaad mathias

00:22:25.910 --> 00:22:26.990
heb je een idee

00:22:27.103 --> 00:22:28.423
gebruik eventueel je micro

00:22:28.503 --> 00:22:29.843
wat de uitvoer is

00:22:31.063 --> 00:22:31.843
bij arthur

00:22:41.943 --> 00:22:45.317
anders de eerste rij alleen, als je die even in de chat zet

00:22:48.526 --> 00:22:50.666
dan volgen de andere 6 rijen vanzelf denk ik.

00:22:56.350 --> 00:22:57.903
ja, dat klopt ubderdaad

00:22:57.943 --> 00:22:59.583
wij krijgen daar 6 keer artuur

00:22:59.903 --> 00:23:01.836
omdat arthur bestaat uit 6 letters

00:23:02.074 --> 00:23:04.740
dus dit hier deze tweede expressie hier

00:23:04.934 --> 00:23:07.627
select regexp_split_to_table

00:23:08.334 --> 00:23:10.474
functie die de naam gaat opsplitsen

00:23:10.766 --> 00:23:12.226
in aparte karakters

00:23:12.313 --> 00:23:14.360
dan krijg ik a,r,t enzoverder

00:23:14.546 --> 00:23:15.253
zes letters

00:23:15.766 --> 00:23:16.900


00:23:16.933 --> 00:23:15.613
dus ik krijg hier een tabel

00:23:17.360 --> 00:23:18.720
met zes rijen

00:23:18.786 --> 00:23:20.486
die wordt gecombineerd met een rij

00:23:20.533 --> 00:23:21.973
uit die bovenste dus ik krijg

00:23:22.007 --> 00:23:23.067
zes rijen in totaal

00:23:23.180 --> 00:23:24.660
dus ik krijg arthur a

00:23:25.073 --> 00:23:26.013
arthur r

00:23:26.373 --> 00:23:27.400
arthur t

00:23:27.707 --> 00:23:29.907
enzover tot uiteindlijke arthur r

00:23:33.359 --> 00:23:35.293
dat is één manier, begrijpt iedereen waarom ik dat doe

00:23:36.353 --> 00:23:39.726
om eigenlijk over te stappen met mensen met dezelfde

00:23:39.960 --> 00:23:41.260
letter in hun naam hebben

00:23:42.253 --> 00:23:44.036
nu heb ik eibenlijk een tabel gemaakt waarbij

00:23:44.116 --> 00:23:44.783
per naam

00:23:44.976 --> 00:23:46.603
weet welke letter in voorkomt

00:23:46.783 --> 00:23:48.530
dus wat zou de volgende stap kunnen zijn

00:23:48.956 --> 00:23:50.383
op welk niveau ga je nadenken

00:23:55.450 --> 00:23:57.936
dus ik heb dat hier bijvoorbeeld voor arthur weten we dat

00:23:58.750 --> 00:24:01.943
maar moest het iemand anders zijn bv. lucas dan had ik hier vijf rijen

00:24:02.990 --> 00:24:05.630
dan krijgen die l,u enzoverder

00:24:06.327 --> 00:24:08.007
dan krijgen we op een bepaald moment de letter "a"

00:24:09.647 --> 00:24:11.767
dus wat zou je kunnen gaan gebruiken als

00:24:12.347 --> 00:24:15.087
zijnde een . . . conditie

00:24:38.843 --> 00:24:42.070
dus het eerste de eerste keer dat jullie met die letter al werken

00:24:43.016 --> 00:24:44.083
beetje wennen is

00:24:47.523 --> 00:24:48.856
als je eentje verder gaat

00:24:50.027 --> 00:24:51.980
dus die omzetting, zoals daarstraks gezet

00:24:52.013 --> 00:24:53.100
die gebeurt inderdaad

00:24:53.206 --> 00:24:55.053
die arthur, hier gaat het over sjeik

00:24:55.107 --> 00:24:56.420
enzoverder dus alle

00:24:57.066 --> 00:24:59.153
alle elementen worden eigenlijk

00:24:59.180 --> 00:25:00.640
normaal maar één rij voor Sjeik

00:25:00.753 --> 00:25:01.833
heb ik er nu 5

00:25:02.093 --> 00:25:02.940
enzoverder

00:25:03.066 --> 00:25:04.366
dus krijg ik al die mensen

00:25:06.166 --> 00:25:07.573
dus als ik dit heb als tabel

00:25:08.373 --> 00:25:09.706
hoe zou ik nu die tabel

00:25:09.813 --> 00:25:11.346
met zichzelf verbinden?

00:25:12.993 --> 00:25:13.873
zondanig dat

00:25:14.140 --> 00:25:15.586
ik alle mensen krijg

00:25:15.733 --> 00:25:18.506
die een gemeenschappelijk letter hebben in hun voornaam

00:25:19.213 --> 00:25:20.913
hoe kan ik die tabel met zichzelf

00:25:21.020 --> 00:25:22.120
beeld u in dat is een tabel

00:25:23.390 --> 00:25:24.930
met klantnr voornaam l

00:25:25.350 --> 00:25:27.530
hoe kan ik die tabel met zichzelf verbinden zodanig dat ik

00:25:27.763 --> 00:25:28.463
alle mensen

00:25:29.156 --> 00:25:31.910
samen zet die een gemeenschappelijk letter

00:25:31.935 --> 00:25:32.806
hebben in hun voornaam

00:25:40.573 --> 00:25:41.346
wat is dan

00:25:42.546 --> 00:25:43.666
mijn joined conditie

00:25:45.246 --> 00:25:48.606
dus beeld u in ik ga die tabel twee keer oproepen bijvoorbeeld

00:25:52.390 --> 00:25:54.390
wat gaat dan deze join conditie zijn

00:25:54.924 --> 00:25:55.984
dit is tabel

00:25:56.530 --> 00:25:57.744
x1

00:25:57.890 --> 00:26:00.037
en ik roep nog eens tabel x2

00:26:00.110 --> 00:26:02.364
maar dat is eigenlijk dezelfde tabel dus hoe kan ik dan x1 en x2

00:26:02.653 --> 00:26:04.247
gaan verbinden op welke kolom

00:26:07.553 --> 00:26:09.827
gaan samenvoegen, gaan joinen

00:26:21.190 --> 00:26:23.190
ja inderdaad, dus die "L"

00:26:23.610 --> 00:26:25.629
maar zelfs geen like is zelfs niet nodig

00:26:25.737 --> 00:26:26.743
want het is een karakter

00:26:27.717 --> 00:26:29.316
dus ik ga die "L" gebruiken

00:26:29.343 --> 00:26:30.457
inderdaad milan

00:26:30.564 --> 00:26:31.844
x1 l, x2 l

00:26:31.950 --> 00:26:32.984
dus dat systeem

00:26:33.210 --> 00:26:35.250
dus dat zijn de stappen die ik hier heb gedaan

00:26:35.697 --> 00:26:36.597
gaan we inderdaad

00:26:36.837 --> 00:26:38.484
dus willen we per persoon weten

00:26:39.850 --> 00:26:41.177
gemeenschappelijke letter

00:26:41.202 --> 00:26:43.564
dus in eerste instantie wil ik weten wie heeft een gemeenschappelijke letter

00:26:44.404 --> 00:26:45.477
dan kan ik daarstraks

00:26:45.557 --> 00:26:46.724
misschien nog eens gaan tellen

00:26:46.749 --> 00:26:47.564
want dat is een stap dieper

00:26:47.610 --> 00:26:48.830
maar ik ben het probleem

00:26:48.873 --> 00:26:50.053
wij zijn dit aan het opdelen

00:26:50.257 --> 00:26:51.937
dus de join conditie zijn inderdaad

00:26:51.997 --> 00:26:53.190
zijn inderdaad de gemeenschappelijke letters

00:26:53.717 --> 00:26:55.217
dat wil zeggen ik heb die klanten

00:26:56.057 --> 00:26:57.857
en ik ga die eigenlijk opsplitsen

00:26:59.000 --> 00:27:00.233
in de eerste keer

00:27:00.540 --> 00:27:02.626
ik ga die klaten een tweede keer opsplitsen

00:27:02.800 --> 00:27:03.626
dat is goed

00:27:04.266 --> 00:27:05.673
dan krijg ik al die letters

00:27:06.406 --> 00:27:08.553
ik ga zeggen ze moeten dezelfde letters hebben

00:27:09.013 --> 00:27:10.420
dat is die where conditie hier

00:27:11.773 --> 00:27:13.206
en ik ga ook zeggen

00:27:13.906 --> 00:27:16.240
ik ga wel zeggen het moeten andere mensen zijn

00:27:16.393 --> 00:27:18.746
want ik wil weten welke andere mensen gmn. letters hebben

00:27:19.714 --> 00:27:23.834
want het is niet zinvol om te zeggen arthur heeft dezelfde letters als arthur

00:27:24.200 --> 00:27:25.586
klant 1 gaat

00:27:27.820 --> 00:27:28.700
dus vandaar

00:27:29.706 --> 00:27:32.673
de conditie na het opbouwen van die structuur

00:27:33.283 --> 00:27:35.930
een letter gemeenschappelijk hebben maar niet dezelfde klant zijn

00:27:41.380 --> 00:27:43.060
nu zitten we hier

00:27:44.780 --> 00:27:46.020
nu moet ik nog weten

00:27:47.653 --> 00:27:49.206
dus de vraag was

00:27:51.413 --> 00:27:53.487
we willen weten hoeveel mensen er zijn

00:27:53.580 --> 00:27:55.087
dat is wat alle studenten zouden hebben

00:27:55.453 --> 00:27:58.213
hoeveel mensen zijn er die een letter gemeenschappelijk hebben

00:27:58.247 --> 00:27:58.893
met arthur

00:27:59.290 --> 00:28:00.997
hoeveel mensen zijn er die een letter gemeenschappelijk

00:28:01.090 --> 00:28:02.930
hebben met milan enzoverder

00:28:03.570 --> 00:28:05.577
hoe kan ik dat probleem oplossen

00:28:05.617 --> 00:28:06.530
als ik deze query heb

00:28:15.277 --> 00:28:16.843
zijn bijna aan de oplossing

00:28:29.254 --> 00:28:30.720
dus deze query gaat

00:28:31.870 --> 00:28:33.450
geven voor elk persoon

00:28:34.043 --> 00:28:35.723
andere personen die een letter

00:28:35.770 --> 00:28:36.970
gemeenschappelijk hebben buiten zichzelf

00:28:38.283 --> 00:28:39.796
hoe moet ik deze query nog

00:28:40.260 --> 00:28:42.047
beetje aanpassen, uitbreiden om te weten

00:28:42.313 --> 00:28:43.480
hoeveel mensen er zijn

00:28:44.080 --> 00:28:45.540
die een letter gemeenschappelijk hebben

00:28:45.627 --> 00:28:48.100
met jouw naam of met de naam van de persoon

00:28:49.240 --> 00:28:50.207
die op die rij staat

00:28:52.947 --> 00:28:53.973
die group by

00:28:57.807 --> 00:29:00.413
is klant 1 naam en klant 2 naam

00:29:00.447 --> 00:29:01.893
zijn die daar functioneel afhankelijk van

00:29:02.140 --> 00:29:03.700
je moet daar eens goed over nadenken

00:29:07.280 --> 00:29:07.860
dus

00:29:10.427 --> 00:29:11.460
we komen daar wel denk ik

00:29:13.537 --> 00:29:15.044
inderdaad die group by en de count

00:29:15.270 --> 00:29:17.144
dus laat u niet vangen door

00:29:17.169 --> 00:29:18.317
die k2 naam

00:29:18.457 --> 00:29:19.764
als dat ook een andere waarde heeft

00:29:19.789 --> 00:29:20.930
ga je daar foutmeldingen krijgen

00:29:21.204 --> 00:29:22.750
dus inderdaad daar maar gewoon een

00:29:22.857 --> 00:29:23.630
groepering

00:29:24.537 --> 00:29:26.917
dit zijn dan bijvoorbeeld resultaten daar van

00:29:29.370 --> 00:29:30.924
ik wou nog eerst

00:29:31.347 --> 00:29:33.487
een alternatief laten zien zonder lateral

00:29:35.780 --> 00:29:37.473
zonder lateral dit te doen

00:29:37.600 --> 00:29:38.987
ga je eigenlijk werken met subquerys

00:29:39.012 --> 00:29:40.816
at je de resultaten apart gaat berekenen

00:29:41.303 --> 00:29:42.803
dus je gaat bijvoorbeeld hier

00:29:42.863 --> 00:29:44.216
eggen van

00:29:44.376 --> 00:29:46.583
ik ga die namen opsplitsen dit is één tabel

00:29:46.890 --> 00:29:48.343
dus dat programma

00:29:48.376 --> 00:29:49.610
dan kan ik herhalen

00:29:51.443 --> 00:29:52.730
dus zonder lateral

00:29:52.803 --> 00:29:54.330
wil dat zeggen dat dat allemaal verhuist

00:29:54.376 --> 00:29:55.636
naar u select statement

00:29:56.137 --> 00:29:58.110
dus krijg ik dezelfde query als daarstraks

00:29:58.270 --> 00:29:59.357
maar ik ga al die dingen

00:29:59,721 --> 00:30:02,248
dus hier in mijn front zetten. Ik ga die dan

00:30:02,267 --> 00:30:05,506
even kijken, dus ik heb die hier appart berekent eigenlijk.

00:30:05,540 --> 00:30:09,120
Dus dit is ook een optie wou ik maar tonen.

00:30:09,180 --> 00:30:11,280
alle, even kijken. Ik dacht..

00:30:11,523 --> 00:30:14,410
we zullen..., het klopt wat jullie zeggen he, de GROUP BY en de COUNT.

00:30:14,435 --> 00:30:17,576
Ik had de oplossing daarna verwacht, ik heb mijn preview niet aan staan.

00:30:18,137 --> 00:30:19,137
oke

00:30:20,000 --> 00:30:23,509
Dus als we deze query nog even aanpassen

00:30:23,534 --> 00:30:26,821
om het af te ronden want blijkbaar ontbreekt die slide.

00:30:28,367 --> 00:30:30,917
Inderdaad, we gaan die groeperen op klantnummer.

00:30:32,013 --> 00:30:35,506
 Die naam is functioneel afhankelijk dus die kan je ook in je GROUP BY zetten.

00:30:35,526 --> 00:30:38,787
Je krijgt inderdaad gewoon een COUNT die je daar kan bij zetten.

00:30:38,814 --> 00:30:41,980
Dus je kan zeggen: GROUP BY klantnummer en voornaam.

00:30:42,007 --> 00:30:44,693
en die k2 naam moet je weglaten

00:30:44,793 --> 00:30:47,586
of je gaat count van k2 naam door doen.

00:30:47,713 --> 00:30:50,066
Dus dat kan je dan perfect doen.

00:30:50,213 --> 00:30:54,233
Die L1 hebben we niet meer nodig om te zien wat de gemeenschappelijke voorletter is.

00:30:54,258 --> 00:30:56,316
eh.., de gemeenschappelijke letter.

00:30:56,363 --> 00:30:58,663
Dus dat is hier maar ter informatie.

00:30:59,930 --> 00:31:07,453
En dan het andere voorbeeldje zei ik net he, dus zonder letter kunnen we ook eventueel werken als we die dingen appart berekenen.

00:31:08,360 --> 00:31:09,360
oke.

00:31:10,536 --> 00:31:14,130
Dan hebben we nog een ander voorbeeldje.

00:31:14,397 --> 00:31:16,290
Niet-scalaire subqueries

00:31:16,943 --> 00:31:20,129
Wat bedoelen we met een scalaire subquery?

00:31:24,740 --> 00:31:27,913
Weet je nog? We hadden 4 types van subqueries.

00:31:28,167 --> 00:31:30,186
We hadden tabel subqueries,

00:31:30,353 --> 00:31:31,393
we hadden...

00:31:34,317 --> 00:31:36,592
Abstract gezien is het altijd een tabel natuurlijk,

00:31:36,617 --> 00:31:39,721
maar voor beaalde dimenties geven we die een andere naam.

00:31:40,047 --> 00:31:44,340
Dus wat bedoelen we met een scalaire subquery?

00:31:46,246 --> 00:31:51,570
Meerdere rijen en kolommen? Dan spreken we van een tabel subquery Lucas.

00:31:51,667 --> 00:31:57,407
Niet-scalair, dan bedoelen we met dat het meer is dan 1 rij en 1 kolom.

00:31:57,503 --> 00:31:59,803
Dus dat is daar niet scalair.

00:32:00,263 --> 00:32:02,529
Scalaire subquery is dus gewoon 1 maal 1.

00:32:02,897 --> 00:32:03,269
ja.

00:32:03,460 --> 00:32:06,532
maar het gaat hier over
niet scalaire subqueries

00:32:06,563 --> 00:32:11,519
Subqueries waarvan we weten van die zijn niet scalair.

00:32:11,560 --> 00:32:14,093
 Jullie weten ook dat als we in de SELECT een subquery zetten...

00:32:14,706 --> 00:32:17,763
In de Select, ja dan mag daar maar 1 waarde komen.

00:32:18,137 --> 00:32:23,570
Als daar staat "SELECT klantnummer komma" en dan een subquery, daar mag maar 1 waarde uit komen.

00:32:23,684 --> 00:32:28,990
dat hoor daar te staan, dat is de enige manier dat je dat in de SELECT kan toevoegen, maar wat als dat nu niet...

00:32:29,430 --> 00:32:32,273
Dat dan meer dan 1 waarde is, hoe lossen we dat op?

00:32:33,830 --> 00:32:34,830
Oke

00:32:34,896 --> 00:32:35,896
Dus

00:32:36,296 --> 00:32:37,296
Dit Hier.

00:32:37,883 --> 00:32:39,163
Is geen probleem.

00:32:39,713 --> 00:32:41,646
Dit is een Scalaire subquery.

00:32:41,833 --> 00:32:45,023
He, ik zoek hier dingen op van reizen,...

00:32:45,544 --> 00:32:49,563
En ik schrijf een subquery in mijn SELECT en da maximum is 1 waarde.

00:32:49,820 --> 00:32:52,053
En het is een gecorelleerde subquery.

00:32:52,120 --> 00:32:53,253
Opzich geen probleem.

00:32:53,293 --> 00:32:58,366
is die nu gecorelleerd of niet, het belangrijkste is dat er hier maar 1 waarde uit komt waardoor dat dit perfect uitvoerd.

00:32:58,399 --> 00:33:03,773
Je moet altijdin het achterhoof houden, heeft dat dan de vorm van een tabel, is dat logisch?

00:33:04,460 --> 00:33:05,980
Dus dit is geen probleem, maar...

00:33:07,313 --> 00:33:08,806
Wat als ik dit nu zet?

00:33:09,313 --> 00:33:11,666
Dan krijg je inderdaad die foutmelding.

00:33:13,910 --> 00:33:17,090
Die verblijfsduur, dat kunnen meerdere verblijfsduren hier zijn.

00:33:17,160 --> 00:33:21,460
Voor dezelfde reis zij er waarschijnlijk meerdere bezoeken dus ook meerdere verblijfsduren.

00:33:21,970 --> 00:33:22,443
dus

00:33:22,896 --> 00:33:26,676
Hier komt reis 1 met 7 verschillende verbijfsduren.

00:33:26,693 --> 00:33:32,209
Nu kan je wel denken van ja, voor mij maakt dat dat logisch. Ik kan dat zoals die latteral terug gaan aanvullen. Maar zo werkt dat niet.

00:33:32,393 --> 00:33:35,061
De standard is niet zo gedefinieerd.

00:33:35,086 --> 00:33:37,539
Dus die verwacht daar altijd 1 waarde.

00:33:38,367 --> 00:33:40,100
Dus dan krijg je die fout.

00:33:40,780 --> 00:33:43,593
Dus hoe kunnen we dat oplossen? ook met die latteral weer.

00:33:43,967 --> 00:33:44,967
dus euh...

00:33:46,324 --> 00:33:48,223
Aja dit voorbeeldje kan ik ook nog geven.

00:33:54,700 --> 00:34:00,520
Het moet echt 1 maal 1 zijn voor subquery, want hier komt er maar 1tje uit, het zijn ook agregatiefuncties, komt 1 rijuit

00:34:00,620 --> 00:34:02,300
maar wel met 2 kolomen

00:34:02,327 --> 00:34:07,050
Dit zou je natuurlijk kunnen oplossen door dat op te splitsen in 2 gecorelleerde subqueries. 1tje voor som,

00:34:07,144 --> 00:34:08,744
1tje voor variantie.

00:34:09,494 --> 00:34:10,494
maar goed.

00:34:11,767 --> 00:34:14,026
Toon het maar voor de voledigheid voor de mensen die zich...

00:34:14,133 --> 00:34:16,667
Das een vraag die ik soms krijg.

00:34:16,680 --> 00:34:18,986
Dus de oplossing hier is lateral eh.

00:34:19,056 --> 00:34:20,576
Ja, we gaan onze...

00:34:20,616 --> 00:34:24,904
Hetgeen dat in onze SELECT stond gaan we verhuiszen naan onze FROM.

00:34:25,103 --> 00:34:26,936
We zeggen we willen al die reizen.

00:34:27,170 --> 00:34:33,042
Maar naast die reizen willen we ook per rijs een keer gaan kijken, hoe zit hethier met de verblijfsduur, zowel de som als de variantie.

00:34:33,174 --> 00:34:35,113
voor die reis, en ik voeg dat toe.

00:34:35,247 --> 00:34:37,120
en ik ga dat dan tonen.

00:34:37,480 --> 00:34:41,430
Het woordje lateral is hier nodig omdat verblijfsduur uit reizen komt.

00:34:42,484 --> 00:34:45,150
Uit de tabel reizen op een niveau hoger.

00:34:45,587 --> 00:34:46,587
oke

00:34:48,360 --> 00:34:51,027
Dus dan krijgenwe dit hier bijvoorbeeld.

00:34:51,150 --> 00:34:52,950
We krijgen hier variantie 0

00:34:53,060 --> 00:34:59,040
Ja, dat wilt zeggen dat er maar 1 bezoek is voor die reis. 31

00:34:59,746 --> 00:35:00,746
oke

00:35:06,947 --> 00:35:12,176
We zouden die query van daarnet ook zo kunnen schrijven, die eerste die ik daar gegevn had zonder die agregatie functies.

00:35:12,206 --> 00:35:14,690
Als we meerdere waarden hebben kunnen we datook zo doen.

00:35:15,813 --> 00:35:16,279
ja

00:35:16,787 --> 00:35:21,730
Nu dit zijn een beetje artificieele voorbeelden. want we kunnen dit natuurlijk ook gaan doen door...

00:35:21,990 --> 00:35:24,934
bezoeken op te schuiven naar een niveau hoger.

00:35:24,964 --> 00:35:27,097
en die dingen te gaan berekenen.

00:35:27,980 --> 00:35:28,980
oke

00:35:29,374 --> 00:35:32,174
We kunen combinaties maken van die dingen.

00:35:32,323 --> 00:35:34,956
Da wilt zeggen, je kan zowel...

00:35:36,050 --> 00:35:38,450
Werken met eenderzijds die latteral.

00:35:38,504 --> 00:35:44,333
We kunnen gaan werken met zelfs agregatiefuncties gecombineerd met een gewone waarde, dus die GROUP BY.

00:35:44,460 --> 00:35:46,713
Dus ge kunt eigenlijk redelijk veel van die dingen gaan doen.

00:35:48,307 --> 00:35:48,846
oke

00:35:52,437 --> 00:35:54,237
Dit is misschien nog eentje.

00:35:54,577 --> 00:35:56,177
Dat ik dan kan tonen.

00:35:56,540 --> 00:35:59,868
dus, jullie hebben al verschilende agregatiefuncties gezien,

00:36:01,290 --> 00:36:03,243
even terug gaan, ja

00:36:07,340 --> 00:36:08,340
moment

00:36:08,647 --> 00:36:11,247
Nu dat voorbeeldstaat er niemeer tussen, dat is niet erg

00:36:11,540 --> 00:36:14,659
Dus de COUNT kennen jullie allemaal.

00:36:14,913 --> 00:36:19,150
maar hetgeen wat we daarnet gedaan hebben met die UN NEST

00:36:19,470 --> 00:36:20,856
dus van een rij

00:36:21,360 --> 00:36:25,313
plat he, terug de oorspronkelijke waarde te gaan normaliseren.

00:36:25,493 --> 00:36:31,099
Kun je ook omgekeerd denormaliseren met een agregatiefucntie zoals array agregate, dus dan zetten we die samen

00:36:31,260 --> 00:36:34,160
Dus das ook een manier waarop je kan werken.

00:36:34,760 --> 00:36:38,408
Dus dan krijg je zoiets, het omgekeerde effect eigenlijk.

00:36:39,980 --> 00:36:45,046
Dan het meest voorkomende geval Denk ik, dus alle voorgaande gevallen die we tot nu toe gezien hebben

00:36:45,167 --> 00:36:49,136
Tenzij je echt met zo een normlisatie/denormalisatie probleem zit.

00:36:49,690 --> 00:36:54,329
Dus dat het gedenormaliseerde data is die je moet gaan normaliseren.

00:36:56,250 --> 00:37:00,826
De meeste queries die we tot nu toe gezien hebben kan je waarschijnlijk nog een ander alternatief vinden.

00:37:00,860 --> 00:37:02,873
Dat je die lateral niet nodig hebt, ja.

00:37:03,254 --> 00:37:09,250
Dit is eentje waardat je die lateral meestal, ja,.. je gaat er meestal niet rond kunnen.

00:37:09,706 --> 00:37:12,606
Dus, we hebben net de presentatie gezien van fetch first.

00:37:12,653 --> 00:37:15,753
Dus we willen dat gaan vergelijken met een beperkt afhankelijk resultaat.

00:37:16,100 --> 00:37:17,780
Dus wat wil dat zeggen?

00:37:18,366 --> 00:37:19,366
oke

00:37:20,460 --> 00:37:23,646
Dus,dit is zo een voorbeeldje? we hebben reizen...

00:37:24,616 --> 00:37:29,339
En we gaan dat joinen met deze subquery maar daar is een afhankelijkheid met die leteral.

00:37:29,687 --> 00:37:32,887
Dus probeer een keer te zien, wat doet deze query?

00:39:41,290 --> 00:39:45,106
Ah sorry, ik had even met het drinken mijn geluid af gezet.

00:39:45,233 --> 00:39:47,373
Goed dat Sasha dat meldt.

00:39:48,000 --> 00:39:52,076
Dus, de hint van Rik inderdaad,

00:39:52,636 --> 00:39:57,796
ofterwijl hetgeen dat Arthuur daar zegt ofterwijl Rik, het gaat over de 2 kleinste of de 2 grootste inderdaad.

00:39:58,506 --> 00:40:02,410
Dus als we het stapsgewijs doorlopen, we hebben hier de tabel reizen in de FROM.

00:40:02,970 --> 00:40:06,022
Alle reizen worden sowieso getoont, hier, LEFT.

00:40:06,800 --> 00:40:09,516
Dan word dat gecombineerd met eventueele bezoeken.

00:40:09,656 --> 00:40:12,262
Dat zie ik aan bezoeken B2

00:40:13,016 --> 00:40:15,516
En de WHERE conditie hier, het gaat voor deze reis.

00:40:16,647 --> 00:40:18,187
Dus de bezoeker van die reis.

00:40:19,173 --> 00:40:22,673
En voor het bezoeken ga ik opzoeken, welke hemelobjecten worden hier eigenlijk bezocht?

00:40:22,737 --> 00:40:26,310
En ik ga ze dan sorteren per diameter, alleen de eerste 2...

00:40:27,170 --> 00:40:29,076
tonen en ophalen.

00:40:29,204 --> 00:40:33,702
Dus dat wil eigenlijk zeggen, ik ga per reis alleen de eerste 2 objecten...

00:40:34,410 --> 00:40:36,433
Die bezocht worden volgens de diameter.

00:40:36,526 --> 00:40:40,066
Nu is de vraag natuurlijk hoe word dit gesorteed? ORDER BY diameter.

00:40:40,296 --> 00:40:42,469
Is dat van klein naar groot of van groot naar klein?

00:40:42,836 --> 00:40:49,770
Als je dat niet onthoudt, is niet erg, ik doe dat ook niet altijd mar dat is inderdaad het systeem dat hier wordt toegepast, we zullen eens kijken.

00:40:51,330 --> 00:40:51,830
oke

00:40:52,110 --> 00:40:55,770
Dus wat je hier ziet staan denk ik als je die diameters ziet oplopen.

00:40:55,943 --> 00:40:58,682
Je ziet hier, na een 32 gaat die er inderdaad over.

00:40:58,956 --> 00:41:02,969
Dus de 2 kleinse hemelobjecten per reis dat hier getoont worden

00:41:04,107 --> 00:41:05,107
oke

00:41:06,140 --> 00:41:06,720
goed

00:41:07,037 --> 00:41:10,590
Dus ter vergelijking, we gaan eens die opzoeken.

00:41:11,050 --> 00:41:13,009
Dit was lijn 32.

00:41:13,456 --> 00:41:18,256
Had ik reis nummer 32, had ik een object van diameter 7 en 14.

00:41:18,586 --> 00:41:21,199
Dus als ik alles bijvoorbeeld eens opzoek van 32

00:41:22,294 --> 00:41:26,420
vind ik daar inderdaad dus van 7, 14 en al die ander zijn groter.

00:41:26,680 --> 00:41:30,787
Dus ik krijg effectief de 2 kleinse objecten wat op die reis bezocht worden.

00:41:33,834 --> 00:41:34,834
oke

00:41:35,240 --> 00:41:42,180
Dus meestal kan je inderdaad zonder die lateral werken, maar sommige problemen kun je iderdaad moeilijk oplossen zonder die lateral.

00:41:42,247 --> 00:41:44,780
Dus als je met zo een voorbeeld zit...

00:41:46,413 --> 00:41:47,613
Zoals dit hier.

00:41:48,720 --> 00:41:52,933
Wanneer dat je eigenlijk een... het staat hier... moment...

00:41:53,370 --> 00:41:56,603
Als je moet vergelijken met een beperkt afhankelijk resultaat.

00:41:56,756 --> 00:41:59,902
Dus dat je eigenlijk bijvoorbeeld denkt, ik heb een subquery nodig.

00:42:00,143 --> 00:42:03,136
Waardat ik die fetch first nodig heb terwijl ik in een efhankelijkheid zit.

00:42:03,707 --> 00:42:06,823
Dan ga je 9/10 die lateral toch nodig hebben.

00:42:07,184 --> 00:42:11,919
Of je zit met dat voorbeeldje van daarstraks met die rij die je wilt gaan denormaliseren.

00:42:12,034 --> 00:42:14,434
Die je wilt gaan normaliseren sorry.

00:42:14,560 --> 00:42:19,799
Dan ga je 9/10 ook zo een lateral nodig hebben alhoewel dat daar soms wel alternatieven voor nodig zijn.

00:42:20,113 --> 00:42:23,802
Voor de rest kan je eigenlijk vaak alternatieve queries schrijven.

00:42:24,603 --> 00:42:27,186
Dan is alleen de vraag, als je die queries schrijft...

00:42:28,626 --> 00:42:31,293
Als je weet hoe dat je dat dan kan doen.

00:42:31,886 --> 00:42:39,062
Ik heb die manier met lateral, ik heb die manier zonder lateral , we gaan die kostprijzen vergelijken om tezien van, welke query kies ik hier nu natuurlijk?

00:42:39,090 --> 00:42:40,090
Dat proberen we jullie..

00:42:40,413 --> 00:42:45,786
dus perfomantie is iets, eenkeer dat je databanken beheerst, dan kom je echt wel in dat gebied van performantie.

00:42:46,530 --> 00:42:47,530
oke

00:42:47,710 --> 00:42:50,177
Zijn er nog vragen over die lateral?

00:42:51,526 --> 00:42:52,646
Lateral joins.

00:43:04,480 --> 00:43:05,480
oke