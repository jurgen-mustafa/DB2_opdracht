WEBVTT

00:00:00.000 --> 00:00:01.722
Lateral joins, ok

00:00:04.270 --> 00:00:05.539
Soms heb je bijvoorbeeld

00:00:05.665 --> 00:00:07.794
Ik toon hier ook af en toe
dingen in die presentaties die je

00:00:07.920 --> 00:00:09.889
Kan gebruiken om ook zelf te experimenteren

00:00:10.270 --> 00:00:11.470
Euhm

00:00:11.697 --> 00:00:12.951
Je hebt snel wat data nodig

00:00:13.274 --> 00:00:14.535
Dus wat doe je hier

00:00:14.663 --> 00:00:17.229
Dit is een functie: generate
series one two three

00:00:17.355 --> 00:00:18.557
Dus 1 2 3

00:00:18.735 --> 00:00:21.221
En ik geef daar dan een naam aan
en ik maak een tijdelijke tabel aan

00:00:21.403 --> 00:00:23.170
Hier staan een aantal dingen, dus dit gaat

00:00:23.374 --> 00:00:25.285
Getallen genereren,
dat heb je wel door denk ik

00:00:25.411 --> 00:00:27.561
Dat is een kolomnaam dat ik daaraan geef

00:00:27.733 --> 00:00:29.185
En ik maak een tijdelijke tabel

00:00:29.683 --> 00:00:31.016
Een tijdelijke tabel is eigenlijk

00:00:31.234 --> 00:00:33.710
In plaats van met een transactie
te werken en rollback te doen

00:00:34.183 --> 00:00:35.383
Euhm

00:00:35.598 --> 00:00:37.113
Een luie manier om te zeggen van

00:00:37.239 --> 00:00:38.372
Ja

00:00:38.498 --> 00:00:41.478
In de achtergrond zitten er
natuurlijk allerlei

00:00:41.635 --> 00:00:44.397
Werkers die in de achtergrond
uw databank in orde houden

00:00:45.000 --> 00:00:46.468
Op het moment dat mijn sessie gedaan is

00:00:46.750 --> 00:00:48.249
En die werkers schieten in actie

00:00:48.415 --> 00:00:50.952
Dan gaan die die tijdelijke tabel
opkuisen en worden die verwijderd

00:00:51.078 --> 00:00:53.807
Dus een beetje zoals de temp
directory op Linux zou je kunnen zeggen

00:00:54.172 --> 00:00:56.481
Dus dat is makkelijk om dingen te testen soms

00:00:57.583 --> 00:00:59.804
Dus we gaan die een keer opvragen.
We zien natuurlijk

00:00:59.930 --> 00:01:03.158
Die nummers 1 2 3 daar dan in verschijnen
in die tijdelijke tabel

00:01:04.251 --> 00:01:05.351
Ok

00:01:06.750 --> 00:01:08.124
Als ik deze query uitvoer he

00:01:08.250 --> 00:01:10.992
De tabel nummers heeft de waardes 1 2 3

00:01:12.033 --> 00:01:14.937
Gaat deze query werken
of is hier een probleem

00:01:19.983 --> 00:01:21.871
Wie ziet er de tabel nummers

00:01:22.014 --> 00:01:23.647
Ik zal hem even terug tonen misschien

00:01:23.808 --> 00:01:25.530
Hij heeft de kolom max_num

00:01:25.967 --> 00:01:27.474
En de waardes 1 2 3

00:01:27.632 --> 00:01:28.949
Dat is de tabel nummers

00:01:29.717 --> 00:01:33.209
Dus als je kijkt naar deze query, is
hier een probleem of gaat dat werken?

00:01:34.050 --> 00:01:35.264
Wat denken jullie?

00:01:45.117 --> 00:01:47.188
Misschien in het wat moeilijk
om die vraag te beantwoorden

00:01:47.343 --> 00:01:50.358
Maar begrijp je conceptueel
wat er hier staat in de FROM

00:01:50.484 --> 00:01:52.819
Wat is de eerste stap die
er in de FROM gebeurt

00:01:55.283 --> 00:01:57.333
Da's altijd dezelfde stap,
want er staat een komma

00:01:57.459 --> 00:01:59.069
Dus de eerste stap is een...

00:02:00.899 --> 00:02:03.382
Cross Join, goed Filip! Cross Join

00:02:04.220 --> 00:02:08.183
Niet geëxpliciteerd, dus we spreken
abstract gezien van een carthesisch product

00:02:08.587 --> 00:02:10.087
Die nummers is 1 2 3

00:02:10.350 --> 00:02:12.217
Maar wat staat er in die tweede tabel

00:02:13.617 --> 00:02:15.217
Wat staat daarin

00:02:19.700 --> 00:02:22.017
Zou je conceptueel kunnen denken

00:02:22.395 --> 00:02:24.968
We hebben dat nog niet gezien, maar
conceptueel zou je misschien kunnen denken

00:02:25.094 --> 00:02:27.189
Ik denk dat daar zoiets gaat inkomen

00:02:31.967 --> 00:02:34.536
Die generate_series begint gewoon
met waarde 1

00:02:34.739 --> 00:02:36.571
En die stopt bij waarde max_num

00:02:36.697 --> 00:02:39.101
En max_num was een kolom uit nummers

00:02:40.017 --> 00:02:41.117
Dus

00:02:42.127 --> 00:02:43.630
Een lijst van 1 tot max_num

00:02:43.804 --> 00:02:45.763
Inderdaad Sigfried, maar wat is die max_num?

00:02:46.198 --> 00:02:49.221
Die max_num komt van
nummers, dus wat verwacht je daar

00:02:51.867 --> 00:02:53.160
Zeer goed Jarne, ja

00:02:53.333 --> 00:02:54.666
Dus jij verwacht inderdaad

00:02:54.967 --> 00:02:56.363
Nummers is een keer 1

00:02:57.100 --> 00:03:00.325
De max_num van nummers is een
keer 1, dus ik verwacht een keer (1, 1)

00:03:00.717 --> 00:03:02.900
Nummers is een keer 2

00:03:03.026 --> 00:03:04.216
De volgende rij daarin

00:03:04.342 --> 00:03:07.104
Dus ik verwacht een keer
generate_series van 1 tot 2

00:03:07.551 --> 00:03:08.670
En nummers is een keer 3

00:03:08.796 --> 00:03:11.575
De laatste rij, dus ik verwacht
generate_series van 1 tot 3

00:03:13.300 --> 00:03:16.212
Dit is hetgeen wat je conceptueel
kan denken, dus da's goed

00:03:16.389 --> 00:03:19.768
Dit gaat een probleem geven,
hij gaat zeggen van kijk euhm

00:03:21.458 --> 00:03:23.752
Dat werkt niet, want ik
vind daar mijn max_num

00:03:24.397 --> 00:03:28.340
En hij ziet dat - hij weet - hij beseft van
kijk dat is aanwezig in de tabel nummers

00:03:28.466 --> 00:03:31.976
Maar je kan daar niet naar verwijzen
omdat dat op hetzelfde niveau zit

00:03:32.193 --> 00:03:34.148
Je kan niet op hetzelfde niveau in de FROM

00:03:34.355 --> 00:03:35.561
Dat gaat niet

00:03:35.987 --> 00:03:38.599
Aan wat soort constructie doet
ons dat eigenlijk hier denken

00:03:38.798 --> 00:03:41.377
Met hetgeen wat we in het
eerste semester gezien hebben

00:03:42.233 --> 00:03:44.367
Die max_num die komt van ergens anders

00:03:45.761 --> 00:03:47.729
Dus als je denkt aan
subquerries, aan wat soort

00:03:47.933 --> 00:03:51.658
Dit is geen subquerry, maar aan wat
soort subquerry doet dit jou dan denken?

00:03:56.300 --> 00:03:58.799
Omdat ik hier een afhankelijkheid heb

00:04:02.254 --> 00:04:04.245
Inderdaad Kim, een gecorreleerde subquerry

00:04:04.621 --> 00:04:07.404
Dus we kunnen inderdaad zoiets
doen als gecorreleerde subquerries

00:04:07.530 --> 00:04:09.673
Maar dan moeten we inderdaad dus

00:04:10.194 --> 00:04:11.503
Dit probleempje oplossen

00:04:11.901 --> 00:04:14.124
En dat doen we door het gebruik van lateral

00:04:14.754 --> 00:04:16.747
Dus lateral wanneer dat
we een subquerry of een

00:04:17.133 --> 00:04:18.508
Deel in de tabel in de FROM

00:04:19.134 --> 00:04:22.741
Hebben staan en we willen verwijzen naar
een ander deel in de FROM dat daar voor staat

00:04:22.948 --> 00:04:24.709
Dan gebruiken we lateral

00:04:25.500 --> 00:04:27.697
Om te zeggen lateral - op
hetzelfde niveau als je wil

00:04:28.088 --> 00:04:29.188
Lateraal

00:04:29.889 --> 00:04:32.228
Dus zo kunnen wij eigenlijk
die verwijzingen gaan maken

00:04:32.354 --> 00:04:33.553
Dus die vorige query

00:04:34.933 --> 00:04:36.488
Dit staat meer in detail natuurlijk

00:04:37.185 --> 00:04:38.391
Misschien even opsommen

00:04:39.356 --> 00:04:42.886
Dus je kunt verwijzen naar een eerdere
tabelreferentie - zoals die nummers

00:04:43.012 --> 00:04:46.274
Je kunt verwijzen naar een eerdere subquery
(als er een subquery in de FROM staat)

00:04:46.560 --> 00:04:48.441
Of je kunt verwijzen naar een functie

00:04:48.703 --> 00:04:51.502
Die een set teruggeeft,
een set returning function

00:04:51.628 --> 00:04:53.313
Dus een functie die een
verzameling teruggeeft

00:04:53.654 --> 00:04:55.876
generate_series is daar één voorbeeld van

00:04:59.277 --> 00:05:01.427
In de standaard

00:05:02.183 --> 00:05:05.847
Is het zelfs toegelaten wanneer
er een set returning function staat

00:05:05.973 --> 00:05:08.731
Van dat eventueel weg te laten -
dus had ik dat daar anders gezet

00:05:08.893 --> 00:05:10.875
Was dat geen tabel geweest
die nummers, maar een

00:05:11.130 --> 00:05:13.621
Set returning function, dan
had ik dat ook zo kunnen doen

00:05:14.117 --> 00:05:15.974
Maar ik raad dit laatste stukje

00:05:16.590 --> 00:05:19.391
Niet aan omdat dat wat verwarrend
kan zijn, het is maar dat je dat weet

00:05:19.775 --> 00:05:23.825
Dus als je verwijst op hetzelfde
niveau, zet dan gewoon lateral

00:05:24.465 --> 00:05:27.469
Maar bij set returning functions
kan je het eventueel weglaten

00:05:28.833 --> 00:05:30.682
Dus ik zet hier mijn lateral

00:05:31.248 --> 00:05:36.307
En vanaf dat moment krijg ik inderdaad
de resultaten die Jarne daar voorspeld had

00:05:36.641 --> 00:05:38.829
Dus ik krijg 1 met 1

00:05:39.017 --> 00:05:40.495
2 is nu mijn max_num hier

00:05:40.833 --> 00:05:44.391
Dus ik krijg 1 en 2 bij generate_series
gecombineerd met die twee

00:05:44.664 --> 00:05:46.664
En voor 3 krijg ik 1 2 3

00:05:49.083 --> 00:05:53.305
Zo zie je eigenlijk er is een
afhankelijkheid in mijn FROM die ik gebruik

00:05:56.335 --> 00:05:58.287
Dus hetgeen wat ik net gezegd heb van kijk

00:05:59.000 --> 00:06:01.928
Deze twee querries, omdat het een generate

00:06:02.410 --> 00:06:04.805
Een set generating function is

00:06:05.013 --> 00:06:08.351
Set returning function kan je
inderdaad nog gebruiken, maar goed

00:06:09.194 --> 00:06:10.972
Toon per klant de leeftijd

00:06:11.339 --> 00:06:13.719
Er zijn verschillende
manieren om dit op te lossen

00:06:15.784 --> 00:06:18.014
Je zou dit kunnen doen
met een lateral join nu

00:06:19.947 --> 00:06:23.067
We hebben klanten, en we
berekenen eigenlijk hier per klant

00:06:23.937 --> 00:06:26.230
De leeftijd en we zeggen van kijk euhm

00:06:30.172 --> 00:06:33.989
Dit is natuurlijk een ingewikkelde constructie
om iets wat je normaal eenvoudiger oplost he

00:06:34.115 --> 00:06:36.615
Toon per klant de leeftijd, hoe
zouden jullie dat normaal doen?

00:06:37.633 --> 00:06:41.497
Het is maar gewoon een eerste voorbeeldje
om te zien dat je nog alternatieven hebt

00:07:06.783 --> 00:07:10.399
Ja inderdaad, je gaat dat gewoon
berekenen, ophalen op die manier he

00:07:14.991 --> 00:07:18.670
Omdat we daar - misschien nog
een kleine nota - omdat we daar een

00:07:19.527 --> 00:07:21.185
Join conditie, left join

00:07:21.426 --> 00:07:22.820
Verwacht hij een join conditie

00:07:23.229 --> 00:07:25.625
Je kan eens zelf nadenken

00:07:25.850 --> 00:07:27.382
Wat is dat hier met die join conditie

00:07:27.705 --> 00:07:30.900
Je kan een keer een andere join conditie
proberen en kijken wat er dan gebeurt

00:07:31.319 --> 00:07:33.398
Dus dat kan je misschien een keer uitproberen

00:07:34.713 --> 00:07:35.813
Dus

00:07:35.939 --> 00:07:37.048
Inderdaad

00:07:37.181 --> 00:07:39.269
Ik heb het eigenlijk verklapt:
is die join conditie nodig?

00:07:39.395 --> 00:07:41.517
Er wordt daar eigenlijk een
carthesisch product genomen he

00:07:42.040 --> 00:07:44.332
Dus ik had hier even goed
kunnen zetten: ON true

00:07:44.552 --> 00:07:45.956
Want als je teruggaat

00:07:46.157 --> 00:07:48.728
Er is niemand die de opmerking
gemaakt heeft, maar leeftijd

00:07:48.936 --> 00:07:50.317
En geboortedatum

00:07:50.567 --> 00:07:52.167
En hier toch age

00:07:52.460 --> 00:07:54.621
Had ik hier nog iets anders kunnen zetten?

00:07:56.027 --> 00:07:58.249
Dus eigenlijk gewoonweg, die true hier

00:07:58.720 --> 00:08:02.824
Dat is gewoon omdat een join, per
definitie verwacht een join conditie

00:08:02.950 --> 00:08:04.817
Tenzij dat hier een
cross join staat natuurlijk

00:08:05.336 --> 00:08:06.436
Dus vandaar

00:08:09.832 --> 00:08:11.498
Dit geeft natuurlijk
weer hetzelfde resultaat

00:08:11.624 --> 00:08:13.982
Dat is dan die cross join
die ik eigenlijk gebruik

00:08:16.626 --> 00:08:20.272
Dus, dat carthesisch product
zoals we gezien hebben en euhm

00:08:20.629 --> 00:08:23.493
Jarne eigenlijk in eerste
instantie intuïtief aanvoelde

00:08:25.179 --> 00:08:27.178
Dat is eigenlijk zoals
jullie dat intuïtief aanvoelen

00:08:27.313 --> 00:08:29.767
Vanuit subquerries, vanuit
programmeren met een

00:08:29.919 --> 00:08:31.861
Een lus die afhankelijk is van een andere lus

00:08:32.183 --> 00:08:36.016
Dus eigenlijk kunnen we die
ON true meestal wel toevoegen

00:08:37.772 --> 00:08:39.452
Dus welk soort join

00:08:40.351 --> 00:08:41.462
Ga je nemen

00:08:43.521 --> 00:08:46.165
Dat hangt van jou af he, dus
je hebt hier die cross, die inner

00:08:46.388 --> 00:08:49.060
Die gaan zich hetzelfde gedragen, maar

00:08:51.100 --> 00:08:52.745
Het carthesisch product zelf

00:08:52.871 --> 00:08:54.753
Dat blijft zich dus hetzelfde gedragen

00:08:54.928 --> 00:08:57.274
Nu gebruik jij left of right of full

00:08:57.538 --> 00:09:00.480
Dan gaan er eventueel data
worden aangevuld die ontbraken

00:09:00.606 --> 00:09:02.669
Die eventueel weggefiltert waren

00:09:07.250 --> 00:09:08.836
We kunnen hier eigenlijk gaan kiezen he

00:09:13.493 --> 00:09:16.483
Je kan gaan werken met een cross
join, je kan gaan werken met een inner join

00:09:16.609 --> 00:09:18.513
Of we kunnen dat gaan
opschrijven gewoonweg met

00:09:18.864 --> 00:09:21.209
Rechtstreeks een kommatje daar te zetten

00:09:21.723 --> 00:09:23.269
Dus dat zijn allemaal opties die je hebt

00:09:23.585 --> 00:09:25.291
Die eigenlijk in dit geval

00:09:25.629 --> 00:09:27.105
Zich hetzelfde gaan gedragen

00:09:28.689 --> 00:09:31.589
Nu als we gaan kijken naar dit hier

00:09:32.127 --> 00:09:33.436
Dan hebben we hier iets anders staan

00:09:34.010 --> 00:09:35.690
Kijk er even naar

00:09:51.067 --> 00:09:52.717
Ziet er iemand het verschil?

00:09:53.014 --> 00:09:55.914
Waar dat het verschil gemaakt wordt