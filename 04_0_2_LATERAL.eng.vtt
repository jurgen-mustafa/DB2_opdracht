WEBVT

00:00:00.000 --> 00:00:01.722
Lateral joins, ok

00:00:04.270 --> 00:00:05.539
Sometimes you have, for example

00:00:05.665 --> 00:00:07.794
From time to time I show things
in these presentations that you

00:00:07.920 --> 00:00:09.889
Can use to experiment on your own as well

00:00:10.270 --> 00:00:11.470
Um

00:00:11.697 --> 00:00:12.951
You need some quick data

00:00:13.274 --> 00:00:14.535
So what do you do here

00:00:14.663 --> 00:00:17.229
This is a function: generate
series one two three

00:00:17.355 --> 00:00:18.557
So 1 2 3

00:00:18.735 --> 00:00:21.221
And I give it a name
and I create a temporary table

00:00:21.403 --> 00:00:23.170
Here are a number of things, so this is going to

00:00:23.374 --> 00:00:25.285
Generate numbers,
I think you've got that down

00:00:25.411 --> 00:00:27.561
That's a column name that I give it.

00:00:27.733 --> 00:00:29.185
And I create a temporary table

00:00:29.683 --> 00:00:31.016
A temporary table is actually

00:00:31.234 --> 00:00:33.710
Instead of working with a transaction
and doing a rollback

00:00:34.183 --> 00:00:35.383
Um

00:00:35.598 --> 00:00:37.113
A lazy way of saying

00:00:37.239 --> 00:00:38.372
Yes

00:00:38.498 --> 00:00:41.478
In the background there are,
of course, all kinds of

00:00:41.635 --> 00:00:44.397
Workers who are keeping your database
in order in the background

00:00:45.000 --> 00:00:46.468
The moment my session is done

00:00:46.750 --> 00:00:48.249
And those workers shoot into action

00:00:48.415 --> 00:00:50.952
Then they clean up that temporary table
and remove it

00:00:51.078 --> 00:00:53.807
So a bit like the temp
directory on Linux you could say

00:00:54.172 --> 00:00:56.481
So that's easy to test things out sometimes

00:00:57.583 --> 00:00:59.804
So we're going to request those again.
We'll see, of course

00:00:59.930 --> 00:01:03.158
Those numbers 1 2 3 then appear
in that temporary table

00:01:04.251 --> 00:01:05.351
Ok

00:01:06.750 --> 00:01:08.124
If I run this query

00:01:08.250 --> 00:01:10.992
The table numbers has the values 1 2 3

00:01:12.033 --> 00:01:14.937
Is this query going to work
or is there a problem here

00:01:19.983 --> 00:01:21.871
Who sees the table numbers

00:01:22.014 --> 00:01:23.647
I'll show him again maybe

00:01:23.808 --> 00:01:25.530
He has the column max_num

00:01:25.967 --> 00:01:27.474
And the values 1 2 3

00:01:27.632 --> 00:01:28.949
That's the table numbers

00:01:29.717 --> 00:01:33.209
So if you look at this query, is there
a problem or is it going to work?

00:01:34.050 --> 00:01:35.264
What do you guys think?

00:01:45.117 --> 00:01:47.188
Maybe it's a little difficult
to answer that question

00:01:47.343 --> 00:01:50.358
But do you understand conceptually
what it says here in the FROM

00:01:50.484 --> 00:01:52.819
What is the first step that
happens in the FROM

00:01:55.283 --> 00:01:57.333
It's always the same step,
because there's a comma

00:01:57.459 --> 00:01:59.069
So the first step is a...

00:02:00.899 --> 00:02:03.382
Cross Join, good Filip! Cross Join

00:02:04.220 --> 00:02:08.183
Not explicitly stated, so we speak
abstractly of a carthesian product

00:02:08.587 --> 00:02:10.087
numbers is 1 2 3

00:02:10.350 --> 00:02:12.217
But what does that second table say

00:02:13.617 --> 00:02:15.217
What does it say

00:02:19.700 --> 00:02:22.017
Could you think conceptually

00:02:22.395 --> 00:02:24.968
We haven't seen that yet, but
conceptually you might be able to think

00:02:25.094 --> 00:02:27.189
I think something like that is going to be in there

00:02:31.967 --> 00:02:34.536
generate_series just starts with value 1

00:02:34.739 --> 00:02:36.571
And it stops at value max_num

00:02:36.697 --> 00:02:39.101
And max_num was a column from numbers

00:02:40.017 --> 00:02:41.117
So

00:02:42.127 --> 00:02:43.630
A list from 1 to max_num

00:02:43.804 --> 00:02:45.763
Indeed Sigfried, but what is this max_num?

00:02:46.198 --> 00:02:49.221
max_num comes from numbers,
so what do you expect there

00:02:51.867 --> 00:02:53.160
Very good Jarne, yes

00:02:53.333 --> 00:02:54.666
So you are indeed expecting

00:02:54.967 --> 00:02:56.363
Numbers is once 1

00:02:57.100 --> 00:03:00.325
The max_num of numbers is one
times 1, so I expect once (1, 1)

00:03:00.717 --> 00:03:02.900
Numbers is one time 2

00:03:03.026 --> 00:03:04.216
The next row in it

00:03:04.342 --> 00:03:07.104
So I expect one time
generate_series from 1 to 2

00:03:07.551 --> 00:03:08.670
And numbers is one time 3

00:03:08.796 --> 00:03:11.575
The last row, so I expect to
generate_series from 1 to 3

00:03:13.300 --> 00:03:16.212
This is what you can conceptually
can think of, so that's good.

00:03:16.389 --> 00:03:19.768
This is going to be a problem,
he's going to say look, um

00:03:21.458 --> 00:03:23.752
That doesn't work, because I
find my max_num

00:03:24.397 --> 00:03:28.340
And he sees that - he knows - he realizes
look that's present in the table numbers

00:03:28.466 --> 00:03:31.976
But you can't refer to that
because that's on the same level

00:03:32.193 --> 00:03:34.148
You can't be at the same level in the FROM

00:03:34.355 --> 00:03:35.561
That's not possible

00:03:35.987 --> 00:03:38.599
What kind of construction does
this remind us of?

00:03:38.798 --> 00:03:41.377
With what we saw in the
first semester

00:03:42.233 --> 00:03:44.367
That max_num comes from somewhere else

00:03:45.761 --> 00:03:47.729
So when you think about
subquerries, what kind of

00:03:47.933 --> 00:03:51.658
This is not a subquerry, but what
kind of subquerry does this remind you of then?

00:03:56.300 --> 00:03:58.799
Because I have a dependency here

00:04:02.254 --> 00:04:04.245
Indeed Kim, a correlated subquerry

00:04:04.621 --> 00:04:07.404
So we can indeed do something like
do like correlated subquerries

00:04:07.530 --> 00:04:09.673
But then indeed we have to

00:04:10.194 --> 00:04:11.503
Solve this little problem

00:04:11.901 --> 00:04:14.124
And we do that by using lateral

00:04:14.754 --> 00:04:16.747
So lateral when we have a
subquerry or a

00:04:17.133 --> 00:04:18.508
Part in the table in the FROM

00:04:19.134 --> 00:04:22.741
And we want to refer to another
part in the FROM that comes before it

00:04:22.948 --> 00:04:24.709
Then we use lateral

00:04:25.500 --> 00:04:27.697
To say lateral - at
the same level as will

00:04:28.088 --> 00:04:29.188
Lateral

00:04:29.889 --> 00:04:32.228
So that's how we can actually
start creating those references

00:04:32.354 --> 00:04:33.553
So that previous query

00:04:34.933 --> 00:04:36.488
This is in more detail of course

00:04:37.185 --> 00:04:38.391
So just to sum it up

00:04:39.356 --> 00:04:42.886
So you can refer to a previous
table reference - like numbers

00:04:43.012 --> 00:04:46.274
You can refer to a previous subquery
(if there is a subquery in the FROM)

00:04:46.560 --> 00:04:48.441
Or you can refer to a function

00:04:48.703 --> 00:04:51.502
Which returns a set,
a set returning function

00:04:51.628 --> 00:04:53.313
So a function that returns a
collection

00:04:53.654 --> 00:04:55.876
generate_series is one example.

00:04:59.277 --> 00:05:01.427
In the standard

00:05:02.183 --> 00:05:05.847
It's even allowed when
there is a set returning function

00:05:05.973 --> 00:05:08.731
Of possibly leaving that out -
so I put that there differently

00:05:08.893 --> 00:05:10.875
Had had numbers not been a table, but a

00:05:11.130 --> 00:05:13.621
Set returning function, then
I could have done that as well

00:05:14.117 --> 00:05:15.974
But I don't recommend this last bit

00:05:16.590 --> 00:05:19.391
Because that can be a little confusing,
it's just so you know [that it exists]

00:05:19.775 --> 00:05:23.825
So if you're referring at the same
level, just put lateral

00:05:24.465 --> 00:05:27.469
But with set returning functions
you can leave it out

00:05:28.833 --> 00:05:30.682
So I put my lateral here

00:05:31.248 --> 00:05:36.307
And from that moment on, I do indeed get
the results that Jarne predicted

00:05:36.641 --> 00:05:38.829
So I get 1 with 1

00:05:39.017 --> 00:05:40.495
2 is now my max_num here

00:05:40.833 --> 00:05:44.391
So I get 1 and 2 at generate_series
combined with those two

00:05:44.664 --> 00:05:46.664
And for 3 I get 1 2 3

00:05:49.083 --> 00:05:53.305
Now you can see that there is a
dependency in my FROM that I use

00:05:56.335 --> 00:05:58.287
So what I just said of look

00:05:59.000 --> 00:06:01.928
These two querries, because it is a generate

00:06:02.410 --> 00:06:04.805
A set generating function is

00:06:05.013 --> 00:06:08.351
Set returning function you can
indeed still use, but well

00:06:09.194 --> 00:06:10.972
Show the age of each customer

00:06:11.339 --> 00:06:13.719
There are several
ways to solve this

00:06:15.784 --> 00:06:18.014
You could do this
with a lateral join now

00:06:19.947 --> 00:06:23.067
We have customers, and here
we actually calculate per customer

00:06:23.937 --> 00:06:26.230
The age and we say look um

00:06:30.172 --> 00:06:33.989
This is of course a complicated construction
to solve something that is normally simpler

00:06:34.115 --> 00:06:36.615
Show per customer the age, how
would you normally do that?

00:06:37.633 --> 00:06:41.497
It's just a first example
to see that you still have alternatives

00:07:06.783 --> 00:07:10.399
Yeah indeed, you're just going to
calculate, retrieve that way

00:07:14.991 --> 00:07:18.670
Because we have - maybe
a little note - because we have a

00:07:19.527 --> 00:07:21.185
Join condition, left join

00:07:21.426 --> 00:07:22.820
He is expecting a join condition

00:07:23.229 --> 00:07:25.625
You can think for yourself

00:07:25.850 --> 00:07:27.382
What is going on with this join condition

00:07:27.705 --> 00:07:30.900
You could try a different join condition
and see what happens

00:07:31.319 --> 00:07:33.398
So you might want to try that out.

00:07:34.713 --> 00:07:35.813
So

00:07:35.939 --> 00:07:37.048
Indeed

00:07:37.181 --> 00:07:39.269
I actually gave it away:
is that join condition necessary?

00:07:39.395 --> 00:07:41.517
There's actually a carthesic
product being taken there

00:07:42.040 --> 00:07:44.332
So I might as well have
put: ON true

00:07:44.552 --> 00:07:45.956
Because if you go back

00:07:46.157 --> 00:07:48.728
There is no one who made the
remark, but age

00:07:48.936 --> 00:07:50.317
And date of birth

00:07:50.567 --> 00:07:52.167
And age over here

00:07:52.460 --> 00:07:54.621
Could I have put something else here?

00:07:56.027 --> 00:07:58.249
So basically just, that true here

00:07:58.720 --> 00:08:02.824
That's just because a join, by
definition expects a join condition

00:08:02.950 --> 00:08:04.817
Unless this is a
cross join of course

00:08:05.336 --> 00:08:06.436
So there you go

00:08:09.832 --> 00:08:11.498
This of course gives
the same result

00:08:11.624 --> 00:08:13.982
That's the cross join
that I actually use

00:08:16.626 --> 00:08:20.272
So, that carthesian product
as we have seen and um

00:08:20.629 --> 00:08:23.493
Jarne actually intuitively
felt at first

00:08:25.179 --> 00:08:27.178
That's actually how
you guys intuitively feel

00:08:27.313 --> 00:08:29.767
From subquerries, from
programming with a

00:08:29.919 --> 00:08:31.861
A loop that depends on another loop

00:08:32.183 --> 00:08:36.016
So usually we can add that
ON true

00:08:37.772 --> 00:08:39.452
So what kind of join

00:08:40.351 --> 00:08:41.462
Are you going to use

00:08:43.521 --> 00:08:46.165
That depends on you, so
you got that cross here, that inner

00:08:46.388 --> 00:08:49.060
Those are going to behave the same way, but

00:08:51.100 --> 00:08:52.745
The carthesian product itself

00:08:52.871 --> 00:08:54.753
So that continues to behave the same way

00:08:54.928 --> 00:08:57.274
Now you use left or right or full

00:08:57.538 --> 00:09:00.480
Then any data that was missing
may be filled in

00:09:00.606 --> 00:09:02.669
That may have been filtered out

00:09:07.250 --> 00:09:08.836
We can actually start choosing here

00:09:13.493 --> 00:09:16.483
You can work with a cross
join, you can work with an inner join

00:09:16.609 --> 00:09:18.513
Or we can write that down simply by

00:09:18.864 --> 00:09:21.209
Directly putting a comma there

00:09:21.723 --> 00:09:23.269
So those are all options that you have

00:09:23.585 --> 00:09:25.291
Which actually in this case

00:09:25.629 --> 00:09:27.105
Are going to behave the same way

00:09:28.689 --> 00:09:31.589
Now if we're going to take a look at this here

00:09:32.127 --> 00:09:33.436
Then we have something else written here

00:09:34.010 --> 00:09:35.690
Take a look at it

00:09:51.067 --> 00:09:52.717
Does anyone see the difference?

00:09:53.014 --> 00:09:55.914
Where that the difference is made