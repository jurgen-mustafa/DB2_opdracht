WEBVT

00:00:00.000 --> 00:00:01.722
Lateral joins, ok

00:00:04.270 --> 00:00:05.539
Sometimes you have, for example

00:00:05.665 --> 00:00:07.794
From time to time I show things
in these presentations that you

00:00:07.920 --> 00:00:09.889
Can use to experiment on your own as well

00:00:10.270 --> 00:00:11.470
Um

00:00:11.697 --> 00:00:12.951
You need some quick data

00:00:13.274 --> 00:00:14.535
So what do you do here

00:00:14.663 --> 00:00:17.229
This is a function: generate
series one two three

00:00:17.355 --> 00:00:18.557
So 1 2 3

00:00:18.735 --> 00:00:21.221
And I give it a name
and I create a temporary table

00:00:21.403 --> 00:00:23.170
Here are a number of things, so this is going to

00:00:23.374 --> 00:00:25.285
Generate numbers,
I think you've got that down

00:00:25.411 --> 00:00:27.561
That's a column name that I give it.

00:00:27.733 --> 00:00:29.185
And I create a temporary table

00:00:29.683 --> 00:00:31.016
A temporary table is actually

00:00:31.234 --> 00:00:33.710
Instead of working with a transaction
and doing a rollback

00:00:34.183 --> 00:00:35.383
Um

00:00:35.598 --> 00:00:37.113
A lazy way of saying

00:00:37.239 --> 00:00:38.372
Yes

00:00:38.498 --> 00:00:41.478
In the background there are,
of course, all kinds of

00:00:41.635 --> 00:00:44.397
Workers who are keeping your database
in order in the background

00:00:45.000 --> 00:00:46.468
The moment my session is done

00:00:46.750 --> 00:00:48.249
And those workers shoot into action

00:00:48.415 --> 00:00:50.952
Then they clean up that temporary table
and remove it

00:00:51.078 --> 00:00:53.807
So a bit like the temp
directory on Linux you could say

00:00:54.172 --> 00:00:56.481
So that's easy to test things out sometimes

00:00:57.583 --> 00:00:59.804
So we're going to request those again.
We'll see, of course

00:00:59.930 --> 00:01:03.158
Those numbers 1 2 3 then appear
in that temporary table

00:01:04.251 --> 00:01:05.351
Ok

00:01:06.750 --> 00:01:08.124
If I run this query

00:01:08.250 --> 00:01:10.992
The table numbers has the values 1 2 3

00:01:12.033 --> 00:01:14.937
Is this query going to work
or is there a problem here

00:01:19.983 --> 00:01:21.871
Who sees the table numbers

00:01:22.014 --> 00:01:23.647
I'll show him again maybe

00:01:23.808 --> 00:01:25.530
He has the column max_num

00:01:25.967 --> 00:01:27.474
And the values 1 2 3

00:01:27.632 --> 00:01:28.949
That's the table numbers

00:01:29.717 --> 00:01:33.209
So if you look at this query, is there
a problem or is it going to work?

00:01:34.050 --> 00:01:35.264
What do you guys think?

00:01:45.117 --> 00:01:47.188
Maybe it's a little difficult
to answer that question

00:01:47.343 --> 00:01:50.358
But do you understand conceptually
what it says here in the FROM

00:01:50.484 --> 00:01:52.819
What is the first step that
happens in the FROM

00:01:55.283 --> 00:01:57.333
It's always the same step,
because there's a comma

00:01:57.459 --> 00:01:59.069
So the first step is a...

00:02:00.899 --> 00:02:03.382
Cross Join, good Filip! Cross Join

00:02:04.220 --> 00:02:08.183
Not explicitly stated, so we speak
abstractly of a carthesian product

00:02:08.587 --> 00:02:10.087
numbers is 1 2 3

00:02:10.350 --> 00:02:12.217
But what does that second table say

00:02:13.617 --> 00:02:15.217
What does it say

00:02:19.700 --> 00:02:22.017
Could you think conceptually

00:02:22.395 --> 00:02:24.968
We haven't seen that yet, but
conceptually you might be able to think

00:02:25.094 --> 00:02:27.189
I think something like that is going to be in there

00:02:31.967 --> 00:02:34.536
generate_series just starts with value 1

00:02:34.739 --> 00:02:36.571
And it stops at value max_num

00:02:36.697 --> 00:02:39.101
And max_num was a column from numbers

00:02:40.017 --> 00:02:41.117
So

00:02:42.127 --> 00:02:43.630
A list from 1 to max_num

00:02:43.804 --> 00:02:45.763
Indeed Sigfried, but what is this max_num?

00:02:46.198 --> 00:02:49.221
max_num comes from numbers,
so what do you expect there

00:02:51.867 --> 00:02:53.160
Very good Jarne, yes

00:02:53.333 --> 00:02:54.666
So you are indeed expecting

00:02:54.967 --> 00:02:56.363
Numbers is once 1

00:02:57.100 --> 00:03:00.325
The max_num of numbers is one
times 1, so I expect once (1, 1)

00:03:00.717 --> 00:03:02.900
Numbers is one time 2

00:03:03.026 --> 00:03:04.216
The next row in it

00:03:04.342 --> 00:03:07.104
So I expect one time
generate_series from 1 to 2

00:03:07.551 --> 00:03:08.670
And numbers is one time 3

00:03:08.796 --> 00:03:11.575
The last row, so I expect to
generate_series from 1 to 3

00:03:13.300 --> 00:03:16.212
This is what you can conceptually
can think of, so that's good.

00:03:16.389 --> 00:03:19.768
This is going to be a problem,
he's going to say look, um

00:03:21.458 --> 00:03:23.752
That doesn't work, because I
find my max_num

00:03:24.397 --> 00:03:28.340
And he sees that - he knows - he realizes
look that's present in the table numbers

00:03:28.466 --> 00:03:31.976
But you can't refer to that
because that's on the same level

00:03:32.193 --> 00:03:34.148
You can't be at the same level in the FROM

00:03:34.355 --> 00:03:35.561
That's not possible

00:03:35.987 --> 00:03:38.599
What kind of construction does
this remind us of?

00:03:38.798 --> 00:03:41.377
With what we saw in the
first semester

00:03:42.233 --> 00:03:44.367
That max_num comes from somewhere else

00:03:45.761 --> 00:03:47.729
So when you think about
subquerries, what kind of

00:03:47.933 --> 00:03:51.658
This is not a subquerry, but what
kind of subquerry does this remind you of then?

00:03:56.300 --> 00:03:58.799
Because I have a dependency here

00:04:02.254 --> 00:04:04.245
Indeed Kim, a correlated subquerry

00:04:04.621 --> 00:04:07.404
So we can indeed do something like
do like correlated subquerries

00:04:07.530 --> 00:04:09.673
But then indeed we have to

00:04:10.194 --> 00:04:11.503
Solve this little problem

00:04:11.901 --> 00:04:14.124
And we do that by using lateral

00:04:14.754 --> 00:04:16.747
So lateral when we have a
subquerry or a

00:04:17.133 --> 00:04:18.508
Part in the table in the FROM

00:04:19.134 --> 00:04:22.741
And we want to refer to another
part in the FROM that comes before it

00:04:22.948 --> 00:04:24.709
Then we use lateral

00:04:25.500 --> 00:04:27.697
To say lateral - at
the same level as will

00:04:28.088 --> 00:04:29.188
Lateral

00:04:29.889 --> 00:04:32.228
So that's how we can actually
start creating those references

00:04:32.354 --> 00:04:33.553
So that previous query

00:04:34.933 --> 00:04:36.488
This is in more detail of course

00:04:37.185 --> 00:04:38.391
So just to sum it up

00:04:39.356 --> 00:04:42.886
So you can refer to a previous
table reference - like numbers

00:04:43.012 --> 00:04:46.274
You can refer to a previous subquery
(if there is a subquery in the FROM)

00:04:46.560 --> 00:04:48.441
Or you can refer to a function

00:04:48.703 --> 00:04:51.502
Which returns a set,
a set returning function

00:04:51.628 --> 00:04:53.313
So a function that returns a
collection

00:04:53.654 --> 00:04:55.876
generate_series is one example.

00:04:59.277 --> 00:05:01.427
In the standard

00:05:02.183 --> 00:05:05.847
It's even allowed when
there is a set returning function

00:05:05.973 --> 00:05:08.731
Of possibly leaving that out -
so I put that there differently

00:05:08.893 --> 00:05:10.875
Had had numbers not been a table, but a

00:05:11.130 --> 00:05:13.621
Set returning function, then
I could have done that as well

00:05:14.117 --> 00:05:15.974
But I don't recommend this last bit

00:05:16.590 --> 00:05:19.391
Because that can be a little confusing,
it's just so you know [that it exists]

00:05:19.775 --> 00:05:23.825
So if you're referring at the same
level, just put lateral

00:05:24.465 --> 00:05:27.469
But with set returning functions
you can leave it out

00:05:28.833 --> 00:05:30.682
So I put my lateral here

00:05:31.248 --> 00:05:36.307
And from that moment on, I do indeed get
the results that Jarne predicted

00:05:36.641 --> 00:05:38.829
So I get 1 with 1

00:05:39.017 --> 00:05:40.495
2 is now my max_num here

00:05:40.833 --> 00:05:44.391
So I get 1 and 2 at generate_series
combined with those two

00:05:44.664 --> 00:05:46.664
And for 3 I get 1 2 3

00:05:49.083 --> 00:05:53.305
Now you can see that there is a
dependency in my FROM that I use

00:05:56.335 --> 00:05:58.287
So what I just said of look

00:05:59.000 --> 00:06:01.928
These two querries, because it is a generate

00:06:02.410 --> 00:06:04.805
A set generating function is

00:06:05.013 --> 00:06:08.351
Set returning function you can
indeed still use, but well

00:06:09.194 --> 00:06:10.972
Show the age of each customer

00:06:11.339 --> 00:06:13.719
There are several
ways to solve this

00:06:15.784 --> 00:06:18.014
You could do this
with a lateral join now

00:06:19.947 --> 00:06:23.067
We have customers, and here
we actually calculate per customer

00:06:23.937 --> 00:06:26.230
The age and we say look um

00:06:30.172 --> 00:06:33.989
This is of course a complicated construction
to solve something that is normally simpler

00:06:34.115 --> 00:06:36.615
Show per customer the age, how
would you normally do that?

00:06:37.633 --> 00:06:41.497
It's just a first example
to see that you still have alternatives

00:07:06.783 --> 00:07:10.399
Yeah indeed, you're just going to
calculate, retrieve that way

00:07:14.991 --> 00:07:18.670
Because we have - maybe
a little note - because we have a

00:07:19.527 --> 00:07:21.185
Join condition, left join

00:07:21.426 --> 00:07:22.820
He is expecting a join condition

00:07:23.229 --> 00:07:25.625
You can think for yourself

00:07:25.850 --> 00:07:27.382
What is going on with this join condition

00:07:27.705 --> 00:07:30.900
You could try a different join condition
and see what happens

00:07:31.319 --> 00:07:33.398
So you might want to try that out.

00:07:34.713 --> 00:07:35.813
So

00:07:35.939 --> 00:07:37.048
Indeed

00:07:37.181 --> 00:07:39.269
I actually gave it away:
is that join condition necessary?

00:07:39.395 --> 00:07:41.517
There's actually a carthesic
product being taken there

00:07:42.040 --> 00:07:44.332
So I might as well have
put: ON true

00:07:44.552 --> 00:07:45.956
Because if you go back

00:07:46.157 --> 00:07:48.728
There is no one who made the
remark, but age

00:07:48.936 --> 00:07:50.317
And date of birth

00:07:50.567 --> 00:07:52.167
And age over here

00:07:52.460 --> 00:07:54.621
Could I have put something else here?

00:07:56.027 --> 00:07:58.249
So basically just, that true here

00:07:58.720 --> 00:08:02.824
That's just because a join, by
definition expects a join condition

00:08:02.950 --> 00:08:04.817
Unless this is a
cross join of course

00:08:05.336 --> 00:08:06.436
So there you go

00:08:09.832 --> 00:08:11.498
This of course gives
the same result

00:08:11.624 --> 00:08:13.982
That's the cross join
that I actually use

00:08:16.626 --> 00:08:20.272
So, that carthesian product
as we have seen and um

00:08:20.629 --> 00:08:23.493
Jarne actually intuitively
felt at first

00:08:25.179 --> 00:08:27.178
That's actually how
you guys intuitively feel

00:08:27.313 --> 00:08:29.767
From subquerries, from
programming with a

00:08:29.919 --> 00:08:31.861
A loop that depends on another loop

00:08:32.183 --> 00:08:36.016
So usually we can add that
ON true

00:08:37.772 --> 00:08:39.452
So what kind of join

00:08:40.351 --> 00:08:41.462
Are you going to use

00:08:43.521 --> 00:08:46.165
That depends on you, so
you got that cross here, that inner

00:08:46.388 --> 00:08:49.060
Those are going to behave the same way, but

00:08:51.100 --> 00:08:52.745
The carthesian product itself

00:08:52.871 --> 00:08:54.753
So that continues to behave the same way

00:08:54.928 --> 00:08:57.274
Now you use left or right or full

00:08:57.538 --> 00:09:00.480
Then any data that was missing
may be filled in

00:09:00.606 --> 00:09:02.669
That may have been filtered out

00:09:07.250 --> 00:09:08.836
We can actually start choosing here

00:09:13.493 --> 00:09:16.483
You can work with a cross
join, you can work with an inner join

00:09:16.609 --> 00:09:18.513
Or we can write that down simply by

00:09:18.864 --> 00:09:21.209
Directly putting a comma there

00:09:21.723 --> 00:09:23.269
So those are all options that you have

00:09:23.585 --> 00:09:25.291
Which actually in this case

00:09:25.629 --> 00:09:27.105
Are going to behave the same way

00:09:28.689 --> 00:09:31.589
Now if we're going to take a look at this here

00:09:32.127 --> 00:09:33.436
Then we have something else written here

00:09:34.010 --> 00:09:35.690
Take a look at it

00:09:51.067 --> 00:09:52.717
Does anyone see the difference?

00:09:53.014 --> 00:09:55.914
Where that the difference is made

00:20:00.710 --> 00:20:01.570
example

00:20:01.909 --> 00:20:05.770
 my colleague, amie and i, wim there is the letter "m" in it

00:20:06.056 --> 00:20:08.703
so we have common letters in our first names.

00:20:09.170 --> 00:20:12.070
for example i see there

00:20:12.603 --> 00:20:14.217
lucas is the last one here

00:20:14.497 --> 00:20:17.217
lucas and my name have no common letters.

00:20:17.390 --> 00:20:18.430
lucas and milan do

00:20:19.980 --> 00:20:22.620
lucas and kevin don't either, for example

00:20:23.406 --> 00:20:26.713
  I want to show people who have common letters in their first name

00:20:29.487 --> 00:20:31.587
We can use this for example.

00:20:32.513 --> 00:20:35.527
there is a function like a nest.

00:20:35.552 --> 00:20:38.010
so that we can convert strings to

00:20:38.223 --> 00:20:39.377
separate characters

00:20:39.530 --> 00:20:40.457
that's a first step

00:20:43.097 --> 00:20:45.443
so I can convert names and first names

00:20:45.754 --> 00:20:47.054
so think about it and we'll have that function.

00:20:47.400 --> 00:20:49.614
start converting first names to separate letters

00:20:51.394 --> 00:20:52.007
okay

00:20:53.654 --> 00:20:55.714
then we could actually use that

00:20:55.960 --> 00:20:58.167
then we could use this to get a name

00:20:58.293 --> 00:21:00.393
so like a table was just made

00:21:00.473 --> 00:21:01.987
from one row to the other

00:21:03.280 --> 00:21:04.813
then the corresponding values

00:21:06.277 --> 00:21:07.777
could you do that here

00:21:07.843 --> 00:21:09.270
to actually start combining the names

00:21:09.337 --> 00:21:10.577
with all their separate letters

00:21:10.863 --> 00:21:12.817
understands everybody, I'm going to let it stand for a moment

00:21:14.100 --> 00:21:14.840
for example

00:21:14.993 --> 00:21:16.580
image you are in a table customers state

00:21:16.600 --> 00:21:17.833
just the word

00:21:17.927 --> 00:21:18.600
arthur

00:21:18.873 --> 00:21:20.153
there is only one name

00:21:20.567 --> 00:21:22.360
customer number 1 with arthur

00:21:22.857 --> 00:21:24.484
What is shown here?

00:21:25.297 --> 00:21:26.710
what comes out of this query

00:21:26.735 --> 00:21:27.317
who can say

00:21:30.837 --> 00:21:33.297
image you in table customer has only one row

00:21:34.123 --> 00:21:36.163
called customer 1 rent

00:21:52.050 --> 00:21:54.223
will first ask another question

00:21:54.417 --> 00:21:56.223
how many rows are going to come out of this

00:21:56.857 --> 00:21:57.823
from this query

00:22:05.206 --> 00:22:06.193
one row

00:22:07.714 --> 00:22:09.340
people who have any other ideas?

00:22:12.287 --> 00:22:13.600
remember in there

00:22:14.360 --> 00:22:15.454
you've got something like

00:22:15.520 --> 00:22:16.494
a cartesian product

00:22:16.684 --> 00:22:18.684
but with that dependence from here

00:22:18.924 --> 00:22:19.604
so that

00:22:19.770 --> 00:22:20.657
arthur

00:22:21.070 --> 00:22:23.284
who is going to be on that "k1.vname"

00:22:24.124 --> 00:22:25.230
indeed mathias

00:22:25.910 --> 00:22:26.990
have you got any ideas

00:22:27.103 --> 00:22:28.423
use your microphone.

00:22:28.503 --> 00:22:29.843
what the output is

00:22:31.063 --> 00:22:31.843
at arthur

00:22:41.943 --> 00:22:45.317
otherwise the first row only, if you just put it in the chat

00:22:48.526 --> 00:22:50.666
then the other 6 rows will follow automatically I think.

00:22:56.350 --> 00:22:57.903
yes, that's right

00:22:57.943 --> 00:22:59.583
we get there 6 times artuur

00:22:59.903 --> 00:23:01.836
because artuur consists of 6 letters.

00:23:02.074 --> 00:23:04.740
so this here this second expression here

00:23:04.934 --> 00:23:07.627
select regexp_split_to_table

00:23:08.334 --> 00:23:10.474
function that splits the name

00:23:10.766 --> 00:23:12.226
into separate characters

00:23:12.313 --> 00:23:14.360
Then I get a,r,t and so on.

00:23:14.546 --> 00:23:15.253
six letters

00:23:15.766 --> 00:23:16.900


00:23:16.933 --> 00:23:15.613
so I get a table here

00:23:17.360 --> 00:23:18.720
with six rows

00:23:18.786 --> 00:23:20.486
which is combined with a row

00:23:20.533 --> 00:23:21.973
from that top one so I get

00:23:22.007 --> 00:23:23.067
six rows in all

00:23:23.180 --> 00:23:24.660
so I get arthur a

00:23:25.073 --> 00:23:26.013
rent r

00:23:26.373 --> 00:23:27.400
ground rent t

00:23:27.707 --> 00:23:29.907
etcover to final arrent r

00:23:33.359 --> 00:23:35.293
that's one way, everybody understands why I do that.

00:23:36.353 --> 00:23:39.726
to actually cross over with people with the same

00:23:39.960 --> 00:23:41.260
letter in their name have

00:23:42.253 --> 00:23:44.036
Now I've actually created a table where

00:23:44.116 --> 00:23:44.783
by name

00:23:44.976 --> 00:23:46.603
knows which letter occurs in

00:23:46.783 --> 00:23:48.530
so what could be the next step

00:23:48.956 --> 00:23:50.383
at what level are you going to think

00:23:55.450 --> 00:23:57.936
so I have that here for example for arthuur we know that

00:23:58.750 --> 00:24:01.943
but if it had to be someone else e.g. lucas i would have five rows here

00:24:02.990 --> 00:24:05.630
Then those l, u and so on.

00:24:06.327 --> 00:24:08.007
Then at some point we get the letter "a".

00:24:09.647 --> 00:24:11.767
so what could you start using as

00:24:12.347 --> 00:24:15.087
being a . . condition


00:24:38.843 --> 00:24:42.070
so the first time you guys have worked with that letter already

00:24:43.016 --> 00:24:44.083
is a little bit of getting used to.

00:24:47.523 --> 00:24:48.856
if you go one step further

00:24:50.027 --> 00:24:51.980
so that conversion, as just put

00:24:52.013 --> 00:24:53.100
it does happen.

00:24:53.206 --> 00:24:55.053
that arthur, here it is about sjeik

00:24:55.107 --> 00:24:56.420
etcetera so all the

00:24:57.066 --> 00:24:59.153
all the elements are actually

00:24:59.180 --> 00:25:00.640
normally only one row for Sheikh

00:25:00.753 --> 00:25:01.833
I now have 5.

00:25:02.093 --> 00:25:02.940
etcetera

00:25:03.066 --> 00:25:04.366
so I get all these people

00:25:06.166 --> 00:25:07.573
so if I have this as a table

00:25:08.373 --> 00:25:09.706
how would I now make that table

00:25:09.813 --> 00:25:11.346
connect to itself?

00:25:12.993 --> 00:25:13.873
such that

00:25:14.140 --> 00:25:15.586
I get all the people

00:25:15.733 --> 00:25:18.506
who have a common letter in their first name

00:25:19.213 --> 00:25:20.913
how can I make that table with itself

00:25:21.020 --> 00:25:22.120
imagine that is a table

00:25:23.390 --> 00:25:24.930
with customer number first name l

00:25:25.350 --> 00:25:27.530
How do I connect that table to itself so that I can

00:25:27.763 --> 00:25:28.463
all the people

00:25:29.156 --> 00:25:31.910
together who have a common letter

00:25:31.935 --> 00:25:32.806
have in their first name

00:25:40.573 --> 00:25:41.346
what is then

00:25:42.546 --> 00:25:43.666
my joined condition

00:25:45.246 --> 00:25:48.606
so imagine i'm going to call up that table twice for example

00:25:52.390 --> 00:25:54.390
what is this join condition going to be.

00:25:54.924 --> 00:25:55.984
This is the table.

00:25:56.530 --> 00:25:57.744
x1

00:25:57.890 --> 00:26:00.037
And I call table x2 again.

00:26:00.110 --> 00:26:02.364
but that's actually the same table so how can I call x1 and x2

00:26:02.653 --> 00:26:04.247
going to connect on which column

00:26:07.553 --> 00:26:09.827
are going to merge, are going to join

00:26:21.190 --> 00:26:23.190
yes indeed, so that "L"

00:26:23.610 --> 00:26:25.629
but not even a like is necessary

00:26:25.737 --> 00:26:26.743
because it's a character

00:26:27.717 --> 00:26:29.316
so I'm going to use that "L"

00:26:29.343 --> 00:26:30.457
That's right, milan.

00:26:30.564 --> 00:26:31.844
x1 l, x2 l

00:26:31.950 --> 00:26:32.984
so that system

00:26:33.210 --> 00:26:35.250
so those are the steps that I've done here

00:26:35.697 --> 00:26:36.597
we are indeed going to

00:26:36.837 --> 00:26:38.484
so we want to know per person

00:26:39.850 --> 00:26:41.177
common letter

00:26:41.202 --> 00:26:43.564
so initially I want to know who has a common letter

00:26:44.404 --> 00:26:45.477
then I can just

00:26:45.557 --> 00:26:46.724
maybe start counting again

00:26:46.749 --> 00:26:47.564
because that's a step deeper

00:26:47.610 --> 00:26:48.830
but I'm the problem

00:26:48.873 --> 00:26:50.053
we are breaking this down

00:26:50.257 --> 00:26:51.937
so the join condition is indeed

00:26:51.997 --> 00:26:53.190
are indeed the common letters

00:26:53.717 --> 00:26:55.217
that is, I have those customers

00:26:56.057 --> 00:26:57.857
and I'm actually going to split them up

00:26:59.000 --> 00:27:00.233
in the first time

00:27:00.540 --> 00:27:02.626
i'm going to split those clats a second time

00:27:02.800 --> 00:27:03.626
that's good.

00:27:04.266 --> 00:27:05.673
Then I get all these letters.

00:27:06.406 --> 00:27:08.553
I'm going to say they must have the same letters

00:27:09.013 --> 00:27:10.420
that's that where condition here

00:27:11.773 --> 00:27:13.206
and I'm also going to say

00:27:13.906 --> 00:27:16.240
I'm going to say it must be other people

00:27:16.393 --> 00:27:18.746
cause I want to know what other people have gmn. letters

00:27:19.714 --> 00:27:23.834
because it doesn't make sense to say arthur has the same letters as arthur

00:27:24.200 --> 00:27:25.586
customer 1 goes

00:27:27.820 --> 00:27:28.700
so hence

00:27:29.706 --> 00:27:32.673
the condition after building that structure

00:27:33.283 --> 00:27:35.930
have a letter in common but are not the same client

00:27:41.380 --> 00:27:43.060
here we are.

00:27:44.780 --> 00:27:46.020
Now I have to know

00:27:47.653 --> 00:27:49.206
so the question was

00:27:51.413 --> 00:27:53.487
we want to know how many people are there

00:27:53.580 --> 00:27:55.087
that's what all students would have

00:27:55.453 --> 00:27:58.213
how many people are there who have one letter in common

00:27:58.247 --> 00:27:58.893
with arthur

00:27:59.290 --> 00:28:00.997
how many people are there who have one letter in common

00:28:01.090 --> 00:28:02.930
with milan and so on.

00:28:03.570 --> 00:28:05.577
how can i solve this problem

00:28:05.617 --> 00:28:06.530
if I have this query

00:28:15.277 --> 00:28:16.843
are almost to the solution

00:28:29.254 --> 00:28:30.720
so this query is going

00:28:31.870 --> 00:28:33.450
give for each person

00:28:34.043 --> 00:28:35.723
other people who have a letter

00:28:35.770 --> 00:28:36.970
in common outside of themselves

00:28:38.283 --> 00:28:39.796
how should i make this query yet

00:28:40.260 --> 00:28:42.047
adjust a little bit, expand to know

00:28:42.313 --> 00:28:43.480
how many people there are

00:28:44.080 --> 00:28:45.540
who have a letter in common

00:28:45.627 --> 00:28:48.100
with your name or with the name of the person

00:28:49.240 --> 00:28:50.207
that's on that row

00:28:52.947 --> 00:28:53.973
that group by

00:28:57.807 --> 00:29:00.413
is customer 1 name and customer 2 name

00:29:00.447 --> 00:29:01.893
are those functionally dependent on that

00:29:02.140 --> 00:29:03.700
you have to think about that

00:29:07.280 --> 00:29:07.860
so

00:29:10.427 --> 00:29:11.460
we'll get there I think

00:29:13.537 --> 00:29:15.044
That's right, the group by and the count.

00:29:15.270 --> 00:29:17.144
so don't get caught by

00:29:17.169 --> 00:29:18.317
that k2 name

00:29:18.457 --> 00:29:19.764
if that has any other value

00:29:19.789 --> 00:29:20.930
you're going to get error messages there.

00:29:21.204 --> 00:29:22.750
so indeed there but just a

00:29:22.857 --> 00:29:23.630
grouping

00:29:24.537 --> 00:29:26.917
These are the results of that, for example.

00:29:29.370 --> 00:29:30.924
I wanted to first

00:29:31.347 --> 00:29:33.487
an alternative without lateral

00:29:35.780 --> 00:29:37.473
without lateral do this

00:29:37.600 --> 00:29:38.987
are you actually going to be working with subquerys

00:29:39.012 --> 00:29:40.816
if you're going to calculate the results separately

00:29:41.303 --> 00:29:42.803
so you go for example here

00:29:42.863 --> 00:29:44.216
harrow from

00:29:44.376 --> 00:29:46.583
I'm going to break those names down this is one table

00:29:46.890 --> 00:29:48.343
so that program

00:29:48.376 --> 00:29:49.610
then I can repeat

00:29:51.443 --> 00:29:52.730
so without lateral

00:29:52.803 --> 00:29:54.330
does that mean that all of that moves

00:29:54.376 --> 00:29:55.636
to you select statement

00:29:56.137 --> 00:29:58.110
so I get the same query as before.

00:29:58.270 --> 00:29:59.357
but I'm going to do all those things

00:29:59.623 --> 00:30:01.790
into my from here.

Translated with www.DeepL.com/Translator (free version)