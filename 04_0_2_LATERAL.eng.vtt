WEBVTT

00:00:00.000 --> 00:00:01.722
Lateral joins, ok

00:00:04.270 --> 00:00:05.539
Sometimes you have, for example

00:00:05.665 --> 00:00:07.794
From time to time I show things
in these presentations that you

00:00:07.920 --> 00:00:09.889
Can use to experiment on your own as well

00:00:10.270 --> 00:00:11.470
Um

00:00:11.697 --> 00:00:12.951
You need some quick data

00:00:13.274 --> 00:00:14.535
So what do you do here

00:00:14.663 --> 00:00:17.229
This is a function: generate
series one two three

00:00:17.355 --> 00:00:18.557
So 1 2 3

00:00:18.735 --> 00:00:21.221
And I give it a name
and I create a temporary table

00:00:21.403 --> 00:00:23.170
Here are a number of things, so this is going to

00:00:23.374 --> 00:00:25.285
Generate numbers,
I think you've got that down

00:00:25.411 --> 00:00:27.561
That's a column name that I give it.

00:00:27.733 --> 00:00:29.185
And I create a temporary table

00:00:29.683 --> 00:00:31.016
A temporary table is actually

00:00:31.234 --> 00:00:33.710
Instead of working with a transaction
and doing a rollback

00:00:34.183 --> 00:00:35.383
Um

00:00:35.598 --> 00:00:37.113
A lazy way of saying

00:00:37.239 --> 00:00:38.372
Yes

00:00:38.498 --> 00:00:41.478
In the background there are,
of course, all kinds of

00:00:41.635 --> 00:00:44.397
Workers who are keeping your database
in order in the background

00:00:45.000 --> 00:00:46.468
The moment my session is done

00:00:46.750 --> 00:00:48.249
And those workers shoot into action

00:00:48.415 --> 00:00:50.952
Then they clean up that temporary table
and remove it

00:00:51.078 --> 00:00:53.807
So a bit like the temp
directory on Linux you could say

00:00:54.172 --> 00:00:56.481
So that's easy to test things out sometimes

00:00:57.583 --> 00:00:59.804
So we're going to request those again.
We'll see, of course

00:00:59.930 --> 00:01:03.158
Those numbers 1 2 3 then appear
in that temporary table

00:01:04.251 --> 00:01:05.351
Ok

00:01:06.750 --> 00:01:08.124
If I run this query

00:01:08.250 --> 00:01:10.992
The table numbers has the values 1 2 3

00:01:12.033 --> 00:01:14.937
Is this query going to work
or is there a problem here

00:01:19.983 --> 00:01:21.871
Who sees the table numbers

00:01:22.014 --> 00:01:23.647
I'll show him again maybe

00:01:23.808 --> 00:01:25.530
He has the column max_num

00:01:25.967 --> 00:01:27.474
And the values 1 2 3

00:01:27.632 --> 00:01:28.949
That's the table numbers

00:01:29.717 --> 00:01:33.209
So if you look at this query, is there
a problem or is it going to work?

00:01:34.050 --> 00:01:35.264
What do you guys think?

00:01:45.117 --> 00:01:47.188
Maybe it's a little difficult
to answer that question

00:01:47.343 --> 00:01:50.358
But do you understand conceptually
what it says here in the FROM

00:01:50.484 --> 00:01:52.819
What is the first step that
happens in the FROM

00:01:55.283 --> 00:01:57.333
It's always the same step,
because there's a comma

00:01:57.459 --> 00:01:59.069
So the first step is a...

00:02:00.899 --> 00:02:03.382
Cross Join, good Filip! Cross Join

00:02:04.220 --> 00:02:08.183
Not explicitly stated, so we speak
abstractly of a carthesian product

00:02:08.587 --> 00:02:10.087
numbers is 1 2 3

00:02:10.350 --> 00:02:12.217
But what does that second table say

00:02:13.617 --> 00:02:15.217
What does it say

00:02:19.700 --> 00:02:22.017
Could you think conceptually

00:02:22.395 --> 00:02:24.968
We haven't seen that yet, but
conceptually you might be able to think

00:02:25.094 --> 00:02:27.189
I think something like that is going to be in there

00:02:31.967 --> 00:02:34.536
generate_series just starts with value 1

00:02:34.739 --> 00:02:36.571
And it stops at value max_num

00:02:36.697 --> 00:02:39.101
And max_num was a column from numbers

00:02:40.017 --> 00:02:41.117
So

00:02:42.127 --> 00:02:43.630
A list from 1 to max_num

00:02:43.804 --> 00:02:45.763
Indeed Sigfried, but what is this max_num?

00:02:46.198 --> 00:02:49.221
max_num comes from numbers,
so what do you expect there

00:02:51.867 --> 00:02:53.160
Very good Jarne, yes

00:02:53.333 --> 00:02:54.666
So you are indeed expecting

00:02:54.967 --> 00:02:56.363
Numbers is once 1

00:02:57.100 --> 00:03:00.325
The max_num of numbers is one
times 1, so I expect once (1, 1)

00:03:00.717 --> 00:03:02.900
Numbers is one time 2

00:03:03.026 --> 00:03:04.216
The next row in it

00:03:04.342 --> 00:03:07.104
So I expect one time
generate_series from 1 to 2

00:03:07.551 --> 00:03:08.670
And numbers is one time 3

00:03:08.796 --> 00:03:11.575
The last row, so I expect to
generate_series from 1 to 3

00:03:13.300 --> 00:03:16.212
This is what you can conceptually
can think of, so that's good.

00:03:16.389 --> 00:03:19.768
This is going to be a problem,
he's going to say look, um

00:03:21.458 --> 00:03:23.752
That doesn't work, because I
find my max_num

00:03:24.397 --> 00:03:28.340
And he sees that - he knows - he realizes
look that's present in the table numbers

00:03:28.466 --> 00:03:31.976
But you can't refer to that
because that's on the same level

00:03:32.193 --> 00:03:34.148
You can't be at the same level in the FROM

00:03:34.355 --> 00:03:35.561
That's not possible

00:03:35.987 --> 00:03:38.599
What kind of construction does
this remind us of?

00:03:38.798 --> 00:03:41.377
With what we saw in the
first semester

00:03:42.233 --> 00:03:44.367
That max_num comes from somewhere else

00:03:45.761 --> 00:03:47.729
So when you think about
subquerries, what kind of

00:03:47.933 --> 00:03:51.658
This is not a subquerry, but what
kind of subquerry does this remind you of then?

00:03:56.300 --> 00:03:58.799
Because I have a dependency here

00:04:02.254 --> 00:04:04.245
Indeed Kim, a correlated subquerry

00:04:04.621 --> 00:04:07.404
So we can indeed do something like
do like correlated subquerries

00:04:07.530 --> 00:04:09.673
But then indeed we have to

00:04:10.194 --> 00:04:11.503
Solve this little problem

00:04:11.901 --> 00:04:14.124
And we do that by using lateral

00:04:14.754 --> 00:04:16.747
So lateral when we have a
subquerry or a

00:04:17.133 --> 00:04:18.508
Part in the table in the FROM

00:04:19.134 --> 00:04:22.741
And we want to refer to another
part in the FROM that comes before it

00:04:22.948 --> 00:04:24.709
Then we use lateral

00:04:25.500 --> 00:04:27.697
To say lateral - at
the same level as will

00:04:28.088 --> 00:04:29.188
Lateral

00:04:29.889 --> 00:04:32.228
So that's how we can actually
start creating those references

00:04:32.354 --> 00:04:33.553
So that previous query

00:04:34.933 --> 00:04:36.488
This is in more detail of course

00:04:37.185 --> 00:04:38.391
So just to sum it up

00:04:39.356 --> 00:04:42.886
So you can refer to a previous
table reference - like numbers

00:04:43.012 --> 00:04:46.274
You can refer to a previous subquery
(if there is a subquery in the FROM)

00:04:46.560 --> 00:04:48.441
Or you can refer to a function

00:04:48.703 --> 00:04:51.502
Which returns a set,
a set returning function

00:04:51.628 --> 00:04:53.313
So a function that returns a
collection

00:04:53.654 --> 00:04:55.876
generate_series is one example.

00:04:59.277 --> 00:05:01.427
In the standard

00:05:02.183 --> 00:05:05.847
It's even allowed when
there is a set returning function

00:05:05.973 --> 00:05:08.731
Of possibly leaving that out -
so I put that there differently

00:05:08.893 --> 00:05:10.875
Had had numbers not been a table, but a

00:05:11.130 --> 00:05:13.621
Set returning function, then
I could have done that as well

00:05:14.117 --> 00:05:15.974
But I don't recommend this last bit

00:05:16.590 --> 00:05:19.391
Because that can be a little confusing,
it's just so you know [that it exists]

00:05:19.775 --> 00:05:23.825
So if you're referring at the same
level, just put lateral

00:05:24.465 --> 00:05:27.469
But with set returning functions
you can leave it out

00:05:28.833 --> 00:05:30.682
So I put my lateral here

00:05:31.248 --> 00:05:36.307
And from that moment on, I do indeed get
the results that Jarne predicted

00:05:36.641 --> 00:05:38.829
So I get 1 with 1

00:05:39.017 --> 00:05:40.495
2 is now my max_num here

00:05:40.833 --> 00:05:44.391
So I get 1 and 2 at generate_series
combined with those two

00:05:44.664 --> 00:05:46.664
And for 3 I get 1 2 3

00:05:49.083 --> 00:05:53.305
Now you can see that there is a
dependency in my FROM that I use

00:05:56.335 --> 00:05:58.287
So what I just said of look

00:05:59.000 --> 00:06:01.928
These two querries, because it is a generate

00:06:02.410 --> 00:06:04.805
A set generating function is

00:06:05.013 --> 00:06:08.351
Set returning function you can
indeed still use, but well

00:06:09.194 --> 00:06:10.972
Show the age of each customer

00:06:11.339 --> 00:06:13.719
There are several
ways to solve this

00:06:15.784 --> 00:06:18.014
You could do this
with a lateral join now

00:06:19.947 --> 00:06:23.067
We have customers, and here
we actually calculate per customer

00:06:23.937 --> 00:06:26.230
The age and we say look um

00:06:30.172 --> 00:06:33.989
This is of course a complicated construction
to solve something that is normally simpler

00:06:34.115 --> 00:06:36.615
Show per customer the age, how
would you normally do that?

00:06:37.633 --> 00:06:41.497
It's just a first example
to see that you still have alternatives

00:07:06.783 --> 00:07:10.399
Yeah indeed, you're just going to
calculate, retrieve that way

00:07:14.991 --> 00:07:18.670
Because we have - maybe
a little note - because we have a

00:07:19.527 --> 00:07:21.185
Join condition, left join

00:07:21.426 --> 00:07:22.820
He is expecting a join condition

00:07:23.229 --> 00:07:25.625
You can think for yourself

00:07:25.850 --> 00:07:27.382
What is going on with this join condition

00:07:27.705 --> 00:07:30.900
You could try a different join condition
and see what happens

00:07:31.319 --> 00:07:33.398
So you might want to try that out.

00:07:34.713 --> 00:07:35.813
So

00:07:35.939 --> 00:07:37.048
Indeed

00:07:37.181 --> 00:07:39.269
I actually gave it away:
is that join condition necessary?

00:07:39.395 --> 00:07:41.517
There's actually a carthesic
product being taken there

00:07:42.040 --> 00:07:44.332
So I might as well have
put: ON true

00:07:44.552 --> 00:07:45.956
Because if you go back

00:07:46.157 --> 00:07:48.728
There is no one who made the
remark, but age

00:07:48.936 --> 00:07:50.317
And date of birth

00:07:50.567 --> 00:07:52.167
And age over here

00:07:52.460 --> 00:07:54.621
Could I have put something else here?

00:07:56.027 --> 00:07:58.249
So basically just, that true here

00:07:58.720 --> 00:08:02.824
That's just because a join, by
definition expects a join condition

00:08:02.950 --> 00:08:04.817
Unless this is a
cross join of course

00:08:05.336 --> 00:08:06.436
So there you go

00:08:09.832 --> 00:08:11.498
This of course gives
the same result

00:08:11.624 --> 00:08:13.982
That's the cross join
that I actually use

00:08:16.626 --> 00:08:20.272
So, that carthesian product
as we have seen and um

00:08:20.629 --> 00:08:23.493
Jarne actually intuitively
felt at first

00:08:25.179 --> 00:08:27.178
That's actually how
you guys intuitively feel

00:08:27.313 --> 00:08:29.767
From subquerries, from
programming with a

00:08:29.919 --> 00:08:31.861
A loop that depends on another loop

00:08:32.183 --> 00:08:36.016
So usually we can add that
ON true

00:08:37.772 --> 00:08:39.452
So what kind of join

00:08:40.351 --> 00:08:41.462
Are you going to use

00:08:43.521 --> 00:08:46.165
That depends on you, so
you got that cross here, that inner

00:08:46.388 --> 00:08:49.060
Those are going to behave the same way, but

00:08:51.100 --> 00:08:52.745
The carthesian product itself

00:08:52.871 --> 00:08:54.753
So that continues to behave the same way

00:08:54.928 --> 00:08:57.274
Now you use left or right or full

00:08:57.538 --> 00:09:00.480
Then any data that was missing
may be filled in

00:09:00.606 --> 00:09:02.669
That may have been filtered out

00:09:07.250 --> 00:09:08.836
We can actually start choosing here

00:09:13.493 --> 00:09:16.483
You can work with a cross
join, you can work with an inner join

00:09:16.609 --> 00:09:18.513
Or we can write that down simply by

00:09:18.864 --> 00:09:21.209
Directly putting a comma there

00:09:21.723 --> 00:09:23.269
So those are all options that you have

00:09:23.585 --> 00:09:25.291
Which actually in this case

00:09:25.629 --> 00:09:27.105
Are going to behave the same way

00:09:28.689 --> 00:09:31.589
Now if we're going to take a look at this here

00:09:32.127 --> 00:09:33.436
Then we have something else written here

00:09:34.010 --> 00:09:35.690
Take a look at it

00:09:51.067 --> 00:09:52.717
Does anyone see the difference?

00:09:53.014 --> 00:09:55.914
Where that the difference is made

00:10:13.200 --> 00:10:16.283
I said, if we work with cross join or inner join

00:10:16.550 --> 00:10:18.550
That is actually the same as the comma

00:10:19.200 --> 00:10:20.800
But here something else is going on

00:10:20.800 --> 00:10:22.800
And if sometimes people think, I can

00:10:22.800 --> 00:10:24.400
then why are they different

00:10:24.600 --> 00:10:25.960
These two queries

00:10:46.900 --> 00:10:48.900
You're sitting there with an on condition

00:10:49.267 --> 00:10:51.767
So in the second one, another on condition is added

00:10:51.767 --> 00:10:52.967
Which is not about an equality

00:10:52.980 --> 00:10:56.730
If you think about the relationship that is being calculated here

00:10:56.800 --> 00:10:58.200
So then we refer to that table here, k

00:10:58.783 --> 00:11:00.317
So those things have to match

00:11:00.350 --> 00:11:05.584
So it must be about that name and that birth date coming from k

00:11:05.600 --> 00:11:08.450
Here it is, but you get that filter as well

00:11:16.767 --> 00:11:18.834
So, what you get is from

00:11:20.030 --> 00:11:21.030
Avoid this

00:11:22.600 --> 00:11:26.717
Every right join can be written as a left join

00:11:26.720 --> 00:11:31.300
There are even databases, mysql has not had a right outer join for a long time

00:11:33.570 --> 00:11:36.033
Of course, you can always try to rewrite that as a left outer join

00:11:36.330 --> 00:11:38.167
So the same with that FULL there

00:11:38.217 --> 00:11:41.609
Because the behaviour is indeed not well defined

00:11:42.500 --> 00:11:44.200
So basically you can say

00:11:44.250 --> 00:11:49.667
I have here either a cross join which behaves
like an inner join with an equality

00:11:49.833 --> 00:11:51.867
Like the relationship that is established

00:11:53.017 --> 00:11:57.033
I could possibly specify an additional join condition
that is not about equality

00:11:57.817 --> 00:12:01.067
Then I get a different kind of behaviour,
or I could possibly work with an outer join

00:12:01.170 --> 00:12:07.717
A left outer join with any data that is not present
is present in my dependent part

00:12:08.967 --> 00:12:13.367
To add, from my original
first set table

00:12:18.017 --> 00:12:21.217
Again this should go pretty fast now

00:12:22.000 --> 00:12:30.100
I can simplify this quickly without needing the lateral there join
I can make it more performant

00:12:36.700 --> 00:12:43.633
What does lateral do? Lateral takes care of that k that is there
select age k, birth date that I can get that k

00:12:43.770 --> 00:12:48.283
That one is from customers, so I can get the birth date from it

00:12:48.550 --> 00:12:51.767
Without the word lateral the query is not executed.

00:12:52.500 --> 00:12:57.317
That k birth date, I can see that comes from customers
but I cannot refer to it

00:12:58.150 --> 00:13:01.967
Because the sql standard is defined there

0:13:03.900 --> 00:13:08.650
So that actually makes you analogous to the corralled subqueries
but they are on a lower level

00:13:09.267 --> 00:13:12.851
And here you can refer to something that is on the same level

00:13:14.000 --> 00:13:17.300
So how could this be simpler? I think that was said earlier

00:13:22.700 --> 00:13:24.933
I'm trying to see if everybody is awake

00:13:36.300 --> 00:13:38.967
They actually just calculate the date of birth for each customer.

00:13:39.650 --> 00:13:42.433
The age of the birth date, so just the age actually

00:13:45.117 --> 00:13:47.217
But how to do it more simply?

00:13:52.033 --> 00:13:54.400
Maybe Adam, what do you think?

00:14:05.000 --> 00:14:07.717
Indeed Kevin, no subquery, but just put in the select

00:14:08.100 --> 00:14:11.350
So star, age k birth date

00:14:15.230 --> 00:14:19.283
Indeed Milan, so this piece of age k point birth date you put in the select

00:14:19.883 --> 00:14:22.967
And then delete the rest of what comes after the word lateral

00:14:23.867 --> 00:14:25.333
So yes, fine

00:14:27.967 --> 00:14:35.867
Okay, there are a couple of cases where you say how can we use these lateral joins now

00:14:36.267 --> 00:14:41.083
Because in practice you're going to see, that you're trying to answer questions,
query questions

00:14:41.400 --> 00:14:44.350
When am I going to need it, and if you have problems having
to solve something

00:14:45.533 --> 00:14:48.083
When are you going to think about that lateral

00:14:48.317 --> 00:14:53.783
So it's about normalisation, so it's about a join
 condition that needs to be calculated

00:14:54.000 --> 00:14:56.300
Based on a column that is referred to

00:14:56.517 --> 00:15:02.500
Normalisation means an equalisation of the total sum of something
 from something that is calculated for that

00:15:02.733 --> 00:15:08.667
So, when you actually have subqueries that are dependent

00:15:09.450 --> 00:15:13.800
Subqueries that you want to use the result of
with dependencies

00:15:14.683 --> 00:15:18.033
So an example of normalisation for example

00:15:19.517 --> 00:15:22.667
So, suppose we have a table that is denormalized

00:15:23.067 --> 00:15:26.050
You've all had data modelling techniques

00:15:26.430 --> 00:15:31.183
So that's where we taught you normalisation the reverse way when 
we're going to merge tables

00:15:31.417 --> 00:15:36.533
So add together all possible combinations that are correct 
according to the dependencies

00:15:36.817 --> 00:15:41.900
So just a join between two tables actually,
is a de-normalisation you could say.

00:15:44.317 --> 00:15:47.467
Then we can use that for example

00:15:47.950 --> 00:15:56.283
So, let's say we have for example a denormalized
table, namely saying these are my ids

00:15:56.517 --> 00:15:59.317
They all correspond to other ids

00:16:00.030 --> 00:16:06.083
For example, I have here the row 1, 2, 3,
4, 5, 6 and this row

00:16:09.070 --> 00:16:13.517
So what does that mean if you think about how does this one look,
I don't know it by heart, yeah

00:16:13.800 --> 00:16:19.333
So this is denormalized, because normally what do you expect
in a normalized table, if for instance

00:16:19.567 --> 00:16:24.733
Intermediate table as you popularly call it,
what would it look like?

00:16:25.367 --> 00:16:35.833
So to say that id 1, player 1 for example refers to position 1,
player 1 refers to position 2 and player 1 also refers to position 3

00:16:35.983 --> 00:16:37.850
There is a link, there we know something of position and player

00:16:39.070 --> 00:16:42.967
Player 2 refers to position 4, player 2 also refers to position 5

00:16:43.383 --> 00:16:47.283
So how was this normally stored as you saw it

00:16:50.070 --> 00:16:54.350
If we have a table of players and a table of positions with
between them a many on many

00:16:57.000 --> 00:17:00.533
Then instead of 3 rows here, how many rows?

00:17:08.030 --> 00:17:12.200
To keep track, it is an abstract example here,
indeed Lucas, nine

00:17:12.500 --> 00:17:17.033
1 combined with 1, 1 with 2, 1 with 3,
that's the first 3 rows

00:17:17.200 --> 00:17:19.367
So this is denormalised

00:17:19.967 --> 00:17:23.650
So it's also annoying to have a, you can't say here:
it is an equal to

00:17:24.200 --> 00:17:26.167
It is an embarrassing join condition there

00:17:26.500 --> 00:17:32.517
So, what we're going to do is look euhmmm,
we're going to create a table parent

00:17:32.670 --> 00:17:36.133
So there will be that value 1, 2, 3

00:17:36.133 --> 00:17:42.200
Okay, and we're going to say, we refer to that,
we're sitting with eventual children

00:17:43.430 --> 00:17:47.033
A function that I can use now for example
to break this down

00:17:47.383 --> 00:17:54.217
Is unnest, so that means that when we have denormalized data,
you're going to run into them at some point

00:17:54.367 --> 00:17:58.917
But you will find that it is difficult to work with,
then you can normalise it again.

00:17:59.267 --> 00:18:06.067
And then attach it again, and take it apart with that function, unnest,
so we can convert a row like that

00:18:06.317 --> 00:18:08.233
So that it's all separate values again.

00:18:08.950 --> 00:18:10.800
So, what do I get?

00:18:11.183 --> 00:18:13.683
I had that denormalised table

00:18:14.317 --> 00:18:17.267
And in it were those 1 with 1, 2, 3

00:18:17.700 --> 00:18:20.550
that 2 with, I don't know, 2, 4, 5

00:18:22.230 --> 00:18:26.550
So those other ids that was that 1, 2, 3, that row of 1, 2, 3,
I'm going to unnest them here.

00:18:27.030 --> 00:18:29.133
So that would be 1, 2, 3 in a row.

00:18:29.417 --> 00:18:33.350
So if I join that, I'll get these
these results

00:18:33.750 --> 00:18:38.200
So basically, I get my normalized data back here

00:18:41.200 --> 00:18:44.350
Those 9 rows that Lucas predicted there as well

00:18:46.450 --> 00:18:48.067
So that is 1 possibility

00:18:48.170 --> 00:18:53.467
What does that mean, I did that query,
that's this query, to test whether this is working properly.

00:18:53.600 --> 00:18:59.400
I've got the data here, so I can actually go ahead and suggest to him a way
that they are normalised

00:18:59.500 --> 00:19:04.550
Instead of in a way that they are denormalised,
this is how they are stored now

00:19:04.867 --> 00:19:08.750
For me it's much more interesting that I store them this way

00:19:09.283 --> 00:19:13.783
So all I have to do is, this is a query,
I turn that query into an insert statement.

00:19:14.167 --> 00:19:18.450
By just putting insert in front of it, so insert into the table
that we've created

00:19:19.050 --> 00:19:22.733
So we put it in there

00:19:22.800 --> 00:19:25.367
So that's also something that you can do, which I think you've already figured out

00:19:25.750 --> 00:19:29.633
Insert you can use the values, insert into table, x values

00:19:30.017 --> 00:19:33.517
And then you sum up values, but you can just as well use a select statement there

00:19:33.767 --> 00:19:35.850
For example, to do an insert

00:19:38.050 --> 00:19:45.033
Okay, another case, so we've seen there the case of
normalization, denormalization

00:19:45.383 --> 00:19:50.783
A join condition that has to be calculated based on a
referenced column

00:19:52.270 --> 00:19:55.300
There are other ways to do this but this was about 1 example

00:19:55.667 --> 00:20:00.683
Imagine, you want to know all the people who have a common
 letters in their first name

00:20:00.710 --> 00:20:01.570
example

00:20:01.909 --> 00:20:05.770
my colleague, amie and i, wim there is the letter "m" in it

00:20:06.056 --> 00:20:08.703
so we have common letters in our first names.

00:20:09.170 --> 00:20:12.070
for example i see there

00:20:12.603 --> 00:20:14.217
lucas is the last one here

00:20:14.497 --> 00:20:17.217
lucas and my name have no common letters.

00:20:17.390 --> 00:20:18.430
lucas and milan do

00:20:19.980 --> 00:20:22.620
lucas and kevin don't either, for example

00:20:23.406 --> 00:20:26.713
I want to show people who have common letters in their first name

00:20:29.487 --> 00:20:31.587
We can use this for example.

00:20:32.513 --> 00:20:35.527
there is a function like a nest.

00:20:35.552 --> 00:20:38.010
so that we can convert strings to

00:20:38.223 --> 00:20:39.377
separate characters

00:20:39.530 --> 00:20:40.457
that's a first step

00:20:43.097 --> 00:20:45.443
so I can convert names and first names

00:20:45.754 --> 00:20:47.054
so think about it and we'll have that function.

00:20:47.400 --> 00:20:49.614
start converting first names to separate letters

00:20:51.394 --> 00:20:52.007
okay

00:20:53.654 --> 00:20:55.714
then we could actually use that

00:20:55.960 --> 00:20:58.167
then we could use this to get a name

00:20:58.293 --> 00:21:00.393
so like a table was just made

00:21:00.473 --> 00:21:01.987
from one row to the other

00:21:03.280 --> 00:21:04.813
then the corresponding values

00:21:06.277 --> 00:21:07.777
could you do that here

00:21:07.843 --> 00:21:09.270
to actually start combining the names

00:21:09.337 --> 00:21:10.577
with all their separate letters

00:21:10.863 --> 00:21:12.817
understands everybody, I'm going to let it stand for a moment

00:21:14.100 --> 00:21:14.840
for example

00:21:14.993 --> 00:21:16.580
image you are in a table customers state

00:21:16.600 --> 00:21:17.833
just the word

00:21:17.927 --> 00:21:18.600
arthur

00:21:18.873 --> 00:21:20.153
there is only one name

00:21:20.567 --> 00:21:22.360
customer number 1 with arthur

00:21:22.857 --> 00:21:24.484
What is shown here?

00:21:25.297 --> 00:21:26.710
what comes out of this query

00:21:26.735 --> 00:21:27.317
who can say

00:21:30.837 --> 00:21:33.297
image you in table customer has only one row

00:21:34.123 --> 00:21:36.163
called customer 1 rent

00:21:52.050 --> 00:21:54.223
will first ask another question

00:21:54.417 --> 00:21:56.223
how many rows are going to come out of this

00:21:56.857 --> 00:21:57.823
from this query

00:22:05.206 --> 00:22:06.193
one row

00:22:07.714 --> 00:22:09.340
people who have any other ideas?

00:22:12.287 --> 00:22:13.600
remember in there

00:22:14.360 --> 00:22:15.454
you've got something like

00:22:15.520 --> 00:22:16.494
a cartesian product

00:22:16.684 --> 00:22:18.684
but with that dependence from here

00:22:18.924 --> 00:22:19.604
so that

00:22:19.770 --> 00:22:20.657
arthur

00:22:21.070 --> 00:22:23.284
who is going to be on that "k1.vname"

00:22:24.124 --> 00:22:25.230
indeed mathias

00:22:25.910 --> 00:22:26.990
have you got any ideas

00:22:27.103 --> 00:22:28.423
use your microphone.

00:22:28.503 --> 00:22:29.843
what the output is

00:22:31.063 --> 00:22:31.843
at arthur

00:22:41.943 --> 00:22:45.317
otherwise the first row only, if you just put it in the chat

00:22:48.526 --> 00:22:50.666
then the other 6 rows will follow automatically I think.

00:22:56.350 --> 00:22:57.903
yes, that's right

00:22:57.943 --> 00:22:59.583
we get there 6 times artuur

00:22:59.903 --> 00:23:01.836
because artuur consists of 6 letters.

00:23:02.074 --> 00:23:04.740
so this here this second expression here

00:23:04.934 --> 00:23:07.627
select regexp_split_to_table

00:23:08.334 --> 00:23:10.474
function that splits the name

00:23:10.766 --> 00:23:12.226
into separate characters

00:23:12.313 --> 00:23:14.360
Then I get a,r,t and so on.

00:23:14.546 --> 00:23:15.253
six letters

00:23:15.766 --> 00:23:16.900


00:23:16.933 --> 00:23:15.613
so I get a table here

00:23:17.360 --> 00:23:18.720
with six rows

00:23:18.786 --> 00:23:20.486
which is combined with a row

00:23:20.533 --> 00:23:21.973
from that top one so I get

00:23:22.007 --> 00:23:23.067
six rows in all

00:23:23.180 --> 00:23:24.660
so I get arthur a

00:23:25.073 --> 00:23:26.013
rent r

00:23:26.373 --> 00:23:27.400
ground rent t

00:23:27.707 --> 00:23:29.907
etcover to final arrent r

00:23:33.359 --> 00:23:35.293
that's one way, everybody understands why I do that.

00:23:36.353 --> 00:23:39.726
to actually cross over with people with the same

00:23:39.960 --> 00:23:41.260
letter in their name have

00:23:42.253 --> 00:23:44.036
Now I've actually created a table where

00:23:44.116 --> 00:23:44.783
by name

00:23:44.976 --> 00:23:46.603
knows which letter occurs in

00:23:46.783 --> 00:23:48.530
so what could be the next step

00:23:48.956 --> 00:23:50.383
at what level are you going to think

00:23:55.450 --> 00:23:57.936
so I have that here for example for arthuur we know that

00:23:58.750 --> 00:24:01.943
but if it had to be someone else e.g. lucas i would have five rows here

00:24:02.990 --> 00:24:05.630
Then those l, u and so on.

00:24:06.327 --> 00:24:08.007
Then at some point we get the letter "a".

00:24:09.647 --> 00:24:11.767
so what could you start using as

00:24:12.347 --> 00:24:15.087
being a . . condition

00:24:38.843 --> 00:24:42.070
so the first time you guys have worked with that letter already

00:24:43.016 --> 00:24:44.083
is a little bit of getting used to.

00:24:47.523 --> 00:24:48.856
if you go one step further

00:24:50.027 --> 00:24:51.980
so that conversion, as just put

00:24:52.013 --> 00:24:53.100
it does happen.

00:24:53.206 --> 00:24:55.053
that arthur, here it is about sjeik

00:24:55.107 --> 00:24:56.420
etcetera so all the

00:24:57.066 --> 00:24:59.153
all the elements are actually

00:24:59.180 --> 00:25:00.640
normally only one row for Sheikh

00:25:00.753 --> 00:25:01.833
I now have 5.

00:25:02.093 --> 00:25:02.940
etcetera

00:25:03.066 --> 00:25:04.366
so I get all these people

00:25:06.166 --> 00:25:07.573
so if I have this as a table

00:25:08.373 --> 00:25:09.706
how would I now make that table

00:25:09.813 --> 00:25:11.346
connect to itself?

00:25:12.993 --> 00:25:13.873
such that

00:25:14.140 --> 00:25:15.586
I get all the people

00:25:15.733 --> 00:25:18.506
who have a common letter in their first name

00:25:19.213 --> 00:25:20.913
how can I make that table with itself

00:25:21.020 --> 00:25:22.120
imagine that is a table

00:25:23.390 --> 00:25:24.930
with customer number first name l

00:25:25.350 --> 00:25:27.530
How do I connect that table to itself so that I can

00:25:27.763 --> 00:25:28.463
all the people

00:25:29.156 --> 00:25:31.910
together who have a common letter

00:25:31.935 --> 00:25:32.806
have in their first name

00:25:40.573 --> 00:25:41.346
what is then

00:25:42.546 --> 00:25:43.666
my joined condition

00:25:45.246 --> 00:25:48.606
so imagine i'm going to call up that table twice for example

00:25:52.390 --> 00:25:54.390
what is this join condition going to be.

00:25:54.924 --> 00:25:55.984
This is the table.

00:25:56.530 --> 00:25:57.744
x1

00:25:57.890 --> 00:26:00.037
And I call table x2 again.

00:26:00.110 --> 00:26:02.364
but that's actually the same table so how can I call x1 and x2

00:26:02.653 --> 00:26:04.247
going to connect on which column

00:26:07.553 --> 00:26:09.827
are going to merge, are going to join

00:26:21.190 --> 00:26:23.190
yes indeed, so that "L"

00:26:23.610 --> 00:26:25.629
but not even a like is necessary

00:26:25.737 --> 00:26:26.743
because it's a character

00:26:27.717 --> 00:26:29.316
so I'm going to use that "L"

00:26:29.343 --> 00:26:30.457
That's right, milan.

00:26:30.564 --> 00:26:31.844
x1 l, x2 l

00:26:31.950 --> 00:26:32.984
so that system

00:26:33.210 --> 00:26:35.250
so those are the steps that I've done here

00:26:35.697 --> 00:26:36.597
we are indeed going to

00:26:36.837 --> 00:26:38.484
so we want to know per person

00:26:39.850 --> 00:26:41.177
common letter

00:26:41.202 --> 00:26:43.564
so initially I want to know who has a common letter

00:26:44.404 --> 00:26:45.477
then I can just

00:26:45.557 --> 00:26:46.724
maybe start counting again

00:26:46.749 --> 00:26:47.564
because that's a step deeper

00:26:47.610 --> 00:26:48.830
but I'm the problem

00:26:48.873 --> 00:26:50.053
we are breaking this down

00:26:50.257 --> 00:26:51.937
so the join condition is indeed

00:26:51.997 --> 00:26:53.190
are indeed the common letters

00:26:53.717 --> 00:26:55.217
that is, I have those customers

00:26:56.057 --> 00:26:57.857
and I'm actually going to split them up

00:26:59.000 --> 00:27:00.233
in the first time

00:27:00.540 --> 00:27:02.626
i'm going to split those clats a second time

00:27:02.800 --> 00:27:03.626
that's good.

00:27:04.266 --> 00:27:05.673
Then I get all these letters.

00:27:06.406 --> 00:27:08.553
I'm going to say they must have the same letters

00:27:09.013 --> 00:27:10.420
that's that where condition here

00:27:11.773 --> 00:27:13.206
and I'm also going to say

00:27:13.906 --> 00:27:16.240
I'm going to say it must be other people

00:27:16.393 --> 00:27:18.746
cause I want to know what other people have gmn. letters

00:27:19.714 --> 00:27:23.834
because it doesn't make sense to say arthur has the same letters as arthur

00:27:24.200 --> 00:27:25.586
customer 1 goes

00:27:27.820 --> 00:27:28.700
so hence

00:27:29.706 --> 00:27:32.673
the condition after building that structure

00:27:33.283 --> 00:27:35.930
have a letter in common but are not the same client

00:27:41.380 --> 00:27:43.060
here we are.

00:27:44.780 --> 00:27:46.020
Now I have to know

00:27:47.653 --> 00:27:49.206
so the question was

00:27:51.413 --> 00:27:53.487
we want to know how many people are there

00:27:53.580 --> 00:27:55.087
that's what all students would have

00:27:55.453 --> 00:27:58.213
how many people are there who have one letter in common

00:27:58.247 --> 00:27:58.893
with arthur

00:27:59.290 --> 00:28:00.997
how many people are there who have one letter in common

00:28:01.090 --> 00:28:02.930
with milan and so on.

00:28:03.570 --> 00:28:05.577
how can i solve this problem

00:28:05.617 --> 00:28:06.530
if I have this query

00:28:15.277 --> 00:28:16.843
are almost to the solution

00:28:29.254 --> 00:28:30.720
so this query is going

00:28:31.870 --> 00:28:33.450
give for each person

00:28:34.043 --> 00:28:35.723
other people who have a letter

00:28:35.770 --> 00:28:36.970
in common outside of themselves

00:28:38.283 --> 00:28:39.796
how should i make this query yet

00:28:40.260 --> 00:28:42.047
adjust a little bit, expand to know

00:28:42.313 --> 00:28:43.480
how many people there are

00:28:44.080 --> 00:28:45.540
who have a letter in common

00:28:45.627 --> 00:28:48.100
with your name or with the name of the person

00:28:49.240 --> 00:28:50.207
that's on that row

00:28:52.947 --> 00:28:53.973
that group by

00:28:57.807 --> 00:29:00.413
is customer 1 name and customer 2 name

00:29:00.447 --> 00:29:01.893
are those functionally dependent on that

00:29:02.140 --> 00:29:03.700
you have to think about that

00:29:07.280 --> 00:29:07.860
so

00:29:10.427 --> 00:29:11.460
we'll get there I think

00:29:13.537 --> 00:29:15.044
That's right, the group by and the count.

00:29:15.270 --> 00:29:17.144
so don't get caught by

00:29:17.169 --> 00:29:18.317
that k2 name

00:29:18.457 --> 00:29:19.764
if that has any other value

00:29:19.789 --> 00:29:20.930
you're going to get error messages there.

00:29:21.204 --> 00:29:22.750
so indeed there but just a

00:29:22.857 --> 00:29:23.630
grouping

00:29:24.537 --> 00:29:26.917
These are the results of that, for example.

00:29:29.370 --> 00:29:30.924
I wanted to first

00:29:31.347 --> 00:29:33.487
an alternative without lateral

00:29:35.780 --> 00:29:37.473
without lateral do this

00:29:37.600 --> 00:29:38.987
are you actually going to be working with subquerys

00:29:39.012 --> 00:29:40.816
if you're going to calculate the results separately

00:29:41.303 --> 00:29:42.803
so you go for example here

00:29:42.863 --> 00:29:44.216
harrow from

00:29:44.376 --> 00:29:46.583
I'm going to break those names down this is one table

00:29:46.890 --> 00:29:48.343
so that program

00:29:48.376 --> 00:29:49.610
then I can repeat

00:29:51.443 --> 00:29:52.730
so without lateral

00:29:52.803 --> 00:29:54.330
does that mean that all of that moves

00:29:54.376 --> 00:29:55.636
to you select statement

00:29:56.137 --> 00:29:58.110
so I get the same query as before.

00:29:58.270 --> 00:29:59.357
but I'm going to do all those things

00:29:59.721 --> 00:30:02.248
so put it here in my front. I'm going to put those then

00:30:02.267 --> 00:30:05.506
take a look, so I calculated those here separately actually.

00:30:05.540 --> 00:30:09.1200
So this is also an option I just wanted to show.

00:30:09.180 --> 00:30:11.280
all, let's see. I was thinking.


00:30:11.523 --> 00:30:14.410
we'll.... it's true what you guys are saying he. the GROUP BY and the COUNT.


00:30:14.435 --> 00:30:17.576
I expected the solution after that. i don't have my preview turned on.


00:30:18.137 --> 00:30:19.137
okay


00:30:20.000 --> 00:30:23.509
So if we adjust this query a little bit more


00:30:23.534 --> 00:30:26.821
To finalize it because apparently that slide is missing.


00:30:28.367 --> 00:30:30.917
Indeed. we're going to group those by customer number.


00:30:32.013 --> 00:30:35.506
 That name is functionally dependent so you can put that in your GROUP BY as well.


00:30:35.526 --> 00:30:38.787
Indeed, you just get a COUNT that you can put in there.


00:30:38.814 --> 00:30:41.980
So you can say GROUP BY customer number and first name.


00:30:42.007 --> 00:30:44.693
and that k2 name you should leave out


00:30:44.793 --> 00:30:47.586
or you're going to do count of k2 name by.


00:30:47.713 --> 00:30:50.066
So you can do that perfectly then.


00:30:50.213 --> 00:30:54.233
We don't need that L1 anymore to see what the common initial is.


00:30:54.258 --> 00:30:56.316
er... the common initial.


00:30:56.363 --> 00:30:58.663
So that's just here for your information.


00:30:59.930 --> 00:31:07.453
And then the other little example I just said hey. so without a letter we can also possibly work if we calculate those things separately.


00:31:08.360 --> 00:31:09.360
okay.


00:31:10.536 --> 00:31:14.130
Then we have another little example.


00:31:14.397 --> 00:31:16.290
Non-scalar subqueries


00:31:16.943 --> 00:31:20.129
What do we mean by a scalar subquery?


00:31:24.740 --> 00:31:27.913
Remember? We had 4 types of subqueries.


00:31:28.167 --> 00:31:30.186
We had table subqueries.


00:31:30.353 --> 00:31:31.393
we had...


00:31:34.317 --> 00:31:36.592
Abstractly, it's always a table of course.


00:31:36.617 --> 00:31:39.721
but for certain dimentions we give it a different name.

0
00:31:40.047 --> 00:31:44.340
So what do we mean by a scalar subquery?


00:31:46.246 --> 00:31:51.570
Multiple rows and columns? Then we're talking about a table subquery Lucas.


00:31:51.667 --> 00:31:57.407
NIet-scalar. then we mean by that it is more than 1 row and 1 column.


00:31:57.503 --> 00:31:59.803
So that's not scalar there.


00:32:00.263 --> 00:32:02.529
So scalar subquery is just 1 times 1.


00:32:02.897 --> 00:32:03.269
yes.


00:32:03.460 --> 00:32:06.532
but we're talking about
non scalar subqueries


00:32:06.563 --> 00:32:11.519
Subqueries that we know of that are not scalar.


00:32:11.560 --> 00:32:14.093
 You guys also know that if we put a subquery in the SELECT...


00:32:14.706 --> 00:32:17.763
In the Select. yes then there should only be 1 value there.

0
00:32:18.137 --> 00:32:23.570
If it says "SELECT customer number comma" there and then a subquery. only 1 value should come out of that.


00:32:23.684 --> 00:32:28.990
That should be there. that's the only way you can add that in the SELECT. but what if it's not...


00:32:29.430 --> 00:32:32.273
That then more than 1 value. how do we solve that?


00:32:33.830 --> 00:32:34.830
Okay


00:32:34.896 --> 00:32:35.896
So


00:32:36.296 --> 00:32:37.296
This Right Here.


00:32:37.883 --> 00:32:39.163
Is not a problem.


00:32:39.713 --> 00:32:41.646
This is a Scalar subquery.


00:32:41.833 --> 00:32:45.023
Hey. I'm looking up stuff here from travel....


00:32:45.544 --> 00:32:49.563
And I write a subquery in my SELECT and da maximum is 1 value.

0
00:32:49.820 --> 00:32:52.053
And it's a correlated subquery.


00:32:52.120 --> 00:32:53.253
By itself, no problem.


00:32:53.293 --> 00:32:58.366
The most important thing is that there is only one value that comes out of this, so it is perfect.


00:32:58.399 --> 00:33:03.773
You always have to keep in mind. does that take the form of a table. does that make sense?


00:33:04.460 --> 00:33:05.980
So this is not a problem. but....


00:33:07.313 --> 00:33:08.806
What if I put this now?


00:33:09.313 --> 00:33:11.666
Then indeed you get that error message.


00:33:13.910 --> 00:33:17.090
That length of stay. that could be multiple lengths of stay here.


00:33:17.160 --> 00:33:21.460
For the same trip they are probably multiple visits so also multiple lengths of stay.


00:33:21.970 --> 00:33:22.443
so


00:33:22.896 --> 00:33:26.676
Here comes trip 1 with 7 different lengths of stay.


00:33:26.693 --> 00:33:32.209
Now you may think of yes. to me that makes sense. I can go back and supplement that like that latteral. But that's not how that works.

00:33:32.393 --> 00:33:35.061
The standard is not so defined.


00:33:35.086 --> 00:33:37.539
So it always expects 1 value there.


00:33:38.367 --> 00:33:40.100
So then you get that error.


00:33:40.780 --> 00:33:43.593
So how can we solve that? also with that latteral again.


00:33:43.967 --> 00:33:44.967
so euh...


00:33:46.324 --> 00:33:48.223
Aja this little example I can also give.


00:33:54.700 --> 00:34:00.520
It should really be 1 times 1 for subquery. because here only 1 comes out. they are also agregation functions. comes out 1 row


00:34:00.620 --> 00:34:02.300
but with 2 columns.


00:34:02.327 --> 00:34:07.050
You could of course solve this by splitting that into 2 correlated subqueries. 1 for sum.


00:34:07.144 --> 00:34:08.744
One for variance.


00:34:09.494 --> 00:34:10.494
but good.


00:34:11.767 --> 00:34:14.026
Just show it for completeness for the people who are...


00:34:14.133 --> 00:34:16.667
That's a question I get sometimes.


00:34:16.680 --> 00:34:18.986
So the solution here is lateral eh.


00:34:19.056 --> 00:34:20.576
Yes. we're going to have our...


00:34:20.616 --> 00:34:24.904
The thing that was in our SELECT we're going to move to our FROM.


00:34:25.103 --> 00:34:26.936
We say we want all those trips.


00:34:27.170 --> 00:34:33.042
But in addition to those trips, we want to take a look at each trip. what about the length of stay here. both the sum and the variance.

00:34:33.174 --> 00:34:35.113
for that trip. and I'll add that.


00:34:35.247 --> 00:34:37.120
and I'm going to show that then.


00:34:37.480 --> 00:34:41.430
The word lateral is needed here because length of stay comes from travel.


00:34:42.484 --> 00:34:45.150
From the table travel at one level higher.


00:34:45.587 --> 00:34:46.587
okay


00:34:48.360 --> 00:34:51.027
So then we get this here for example.


00:34:51.150 --> 00:34:52.950
We get here variance 0


00:34:53.060 --> 00:34:59.040
Yes. that means there is only 1 visit for that trip. 31


00:34:59.746 --> 00:35:00.746
okay


00:35:06.947 --> 00:35:12.176
We could also write that query just now. the first one I gave there without those aggregation functions.


00:35:12.206 --> 00:35:14.690
If we have more than one value, we can do that too.


00:35:15.813 --> 00:35:16.279
yes


00:35:16.787 --> 00:35:21.730
Now these are a little bit of artificial examples. because of course we can also start doing this by...


00:35:21.990 --> 00:35:24.934
visits moving up a level.


00:35:24.964 --> 00:35:27.097
And start calculating those things.


00:35:27.980 --> 00:35:28.980
okay


00:35:29.374 --> 00:35:32.174
We can make combinations of those things.


00:35:32.323 --> 00:35:34.956
That is. you can both...


00:35:36.050 --> 00:35:38.450
Work with either that latteral.


00:35:38.504 --> 00:35:44.333
We can start working with even agregation functions combined with a plain value. so that GROUP BY.


00:35:44.460 --> 00:35:46.713
So you can actually start doing a fair amount of those things.


00:35:48.307 --> 00:35:48.846
okay

00:35:52.437 --> 00:35:54.237
This is maybe one more.

00:35:54.577 --> 00:35:56.177
That I can show then.

00:35:56.540 --> 00:35:59.868
So. you guys have already seen different agregation functions.

00:36:01.290 --> 00:36:03.243
going back for a moment. yes

00:36:07.340 --> 00:36:08.340
moment

00:36:08.647 --> 00:36:11.247
Now that example is no longer there. That's okay.

00:36:11.540 --> 00:36:14.659
So the COUNT you all know.


00:36:14.913 --> 00:36:19.150
but the thing that we just did with that UN NEST


00:36:19.470 --> 00:36:20.856
so from a row


00:36:21.360 --> 00:36:25.313
flat he. back to normalize the original value.


00:36:25.493 --> 00:36:31.099
Can you also reverse denormalize with an agregation cucntion like array agregate. so then we put those together


00:36:31.260 --> 00:36:34.160
So das also a way that you can work.


00:36:34.760 --> 00:36:38.408
So then you get something like that. the reverse effect actually.


00:36:39.980 --> 00:36:45.046
Then the most common case I think. so all the previous cases that we've seen so far


00:36:45.167 --> 00:36:49.136
Unless you're really with such a normlization/denormalization problem.


00:36:49.690 --> 00:36:54.329
So that it's denormalized data that you have to go and normalize.


00:36:56.250 --> 00:37:00.826
Most of the queries that we've seen so far you can probably find another alternative.


00:37:00.860 --> 00:37:02.873
That you don't need that lateral. yes.

0
00:37:03.254 --> 00:37:09.250
This is one where that lateral is usually. yes... you're usually not going to be able to get around it.


00:37:09.706 --> 00:37:12.606
So. we just saw the presentation of fetch first.


00:37:12.653 --> 00:37:15.753
So we want to start comparing that to a limited dependent outcome.
00:37:16.100 --> 00:37:17.780
So what does that mean?


00:37:18.366 --> 00:37:19.366
okay


00:37:20.460 --> 00:37:23.646
So.this is such an example? we have travel....


00:37:24.616 --> 00:37:29.339
And we're going to join that with this subquery but there's a dependency there with that leteral.


00:37:29.687 --> 00:37:32.887
So try to see once. what does this query do?


00:39:41.290 --> 00:39:45.106
Ah sorry. I had turned my sound off for a moment with the drinking.


00:39:45.233 --> 00:39:47.373
Good that Sasha reports that.


00:39:48.000 --> 00:39:52.076
So. the hint from Rik indeed.


00:39:52.636 --> 00:39:57.796
oftentimes what Arthuur says there oftentimes Rik. it's about the 2 smallest or the 2 largest indeed.


00:39:58.506 --> 00:40:02.410
So if we go through it step by step. we have the table travel here in the FROM.


00:40:02.970 --> 00:40:06.022
All the trips are shown anyway. here. LEFT.


00:40:06.800 --> 00:40:09.516
Then that's combined with eventual visits.


00:40:09.656 --> 00:40:12.262
I see that in visits B2


00:40:13.016 --> 00:40:15.516
And the WHERE condition here. it goes for this trip.


00:40:16.647 --> 00:40:18.187
So the visitor of that trip.


00:40:19.173 --> 00:40:22.673
And for visiting I'm going to look up. what sky objects are actually visited here?


00:40:22.737 --> 00:40:26.310
And then I'm going to sort them by diameter. just the first 2....

0
00:40:27.170 --> 00:40:29.076
show and retrieve.


00:40:29.204 --> 00:40:33.702
So that basically means. I'm going to per trip only the first 2 objects....


00:40:34.410 --> 00:40:36.433
Which are visited according to the diameter.


00:40:36.526 --> 00:40:40.066
Now the question is of course how is this sorted? ORDER BY diameter.


00:40:40.296 --> 00:40:42.469
Is that from small to large or from large to small?


00:40:42.836 --> 00:40:49.770
If you don't remember that. is not a problem. i don't always do that either but that is indeed the system that is applied here. we will have a look.


00:40:51.330 --> 00:40:51.830
okay


00:40:52.110 --> 00:40:55.770
So what you see here I think when you see those diameters going up.


00:40:55.943 --> 00:40:58.682
You see here. after a 32 it does indeed go over.


00:40:58.956 --> 00:41:02.969
So the 2 smallest celestial objects per trip that are shown here

0
00:41:04.107 --> 00:41:05.107
okay


00:41:06.140 --> 00:41:06.720
good


00:41:07.037 --> 00:41:10.590
So for comparison. we're going to look those up sometime.


00:41:11.050 --> 00:41:13.009
This was line 32.


00:41:13.456 --> 00:41:18.256
Did I have trip number 32. did I have an object of diameter 7 and 14.


00:41:18.586 --> 00:41:21.199
So if I look up everything for example from 32


00:41:22.294 --> 00:41:26.420
I find there indeed so from 7. 14 and all those other are bigger.


00:41:26.680 --> 00:41:30.787
So I get effectively the 2 smallest objects what are visited on that trip.


00:41:33.834 --> 00:41:34.834
okay


00:41:35.240 --> 00:41:42.180
So most of the time you can indeed work without the lateral. but some problems are indeed hard to solve without the lateral.

0
00:41:42.247 --> 00:41:44.780
So when you're sitting with an example like that....


00:41:46.413 --> 00:41:47.613
Like this right here.


00:41:48.720 --> 00:41:52.933
When that you actually have a... it stands here... moment...


00:41:53.370 --> 00:41:56.603
When you have to compare to a limited dependent outcome.


00:41:56.756 --> 00:41:59.902
So that you actually think for example. i need a subquery.


00:42:00.143 --> 00:42:03.136
Where I need that fetch first while I'm in an edependency.


00:42:03.707 --> 00:42:06.823
Then 9/10 you're going to need that lateral anyway.


00:42:07.184 --> 00:42:11.919
Or you're stuck with that little example from earlier with that row that you want to start denormalizing.


00:42:12.034 --> 00:42:14.434
The one you want to go normalize sorry.


00:42:14.560 --> 00:42:19.799
Then 9/10 you're going to need a lateral like that as well although sometimes that does require alternatives.

0
00:42:20.113 --> 00:42:23.802
Other than that, you can actually write alternative queries quite often.


00:42:24.603 --> 00:42:27.186
Then the only question is. if you write those queries.


00:42:28.626 --> 00:42:31.293
If you know how that you can do that then.


00:42:31.886 --> 00:42:39.062
I have that way with lateral. I have that way without lateral . we are going to compare those cost prices to see from. which query do I choose here of course?


00:42:39.090 --> 00:42:40.090
That's what we're trying to do to you guys...


00:42:40.413 --> 00:42:45.786
so perfomance is something. once you master databases. then you really do get into that area of performance.


00:42:46.530 --> 00:42:47.530
okay


00:42:47.710 --> 00:42:50.177
Are there any questions about that lateral?


00:42:51.526 --> 00:42:52.646
Lateral joins.


00:43:04.480 --> 00:43:05.480
okay