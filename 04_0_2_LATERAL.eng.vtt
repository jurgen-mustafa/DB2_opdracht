WEBVTT

00:00:00.000 --> 00:00:01.722
Lateral joins, ok

00:00:04.270 --> 00:00:05.539
Sometimes you have, for example

00:00:05.665 --> 00:00:07.794
From time to time I show things
in these presentations that you

00:00:07.920 --> 00:00:09.889
Can use to experiment on your own as well

00:00:10.270 --> 00:00:11.470
Um

00:00:11.697 --> 00:00:12.951
You need some quick data

00:00:13.274 --> 00:00:14.535
So what do you do here

00:00:14.663 --> 00:00:17.229
This is a function: generate
series one two three

00:00:17.355 --> 00:00:18.557
So 1 2 3

00:00:18.735 --> 00:00:21.221
And I give it a name
and I create a temporary table

00:00:21.403 --> 00:00:23.170
Here are a number of things, so this is going to

00:00:23.374 --> 00:00:25.285
Generate numbers,
I think you've got that down

00:00:25.411 --> 00:00:27.561
That's a column name that I give it.

00:00:27.733 --> 00:00:29.185
And I create a temporary table

00:00:29.683 --> 00:00:31.016
A temporary table is actually

00:00:31.234 --> 00:00:33.710
Instead of working with a transaction
and doing a rollback

00:00:34.183 --> 00:00:35.383
Um

00:00:35.598 --> 00:00:37.113
A lazy way of saying

00:00:37.239 --> 00:00:38.372
Yes

00:00:38.498 --> 00:00:41.478
In the background there are,
of course, all kinds of

00:00:41.635 --> 00:00:44.397
Workers who are keeping your database
in order in the background

00:00:45.000 --> 00:00:46.468
The moment my session is done

00:00:46.750 --> 00:00:48.249
And those workers shoot into action

00:00:48.415 --> 00:00:50.952
Then they clean up that temporary table
and remove it

00:00:51.078 --> 00:00:53.807
So a bit like the temp
directory on Linux you could say

00:00:54.172 --> 00:00:56.481
So that's easy to test things out sometimes

00:00:57.583 --> 00:00:59.804
So we're going to request those again.
We'll see, of course

00:00:59.930 --> 00:01:03.158
Those numbers 1 2 3 then appear
in that temporary table

00:01:04.251 --> 00:01:05.351
Ok

00:01:06.750 --> 00:01:08.124
If I run this query

00:01:08.250 --> 00:01:10.992
The table numbers has the values 1 2 3

00:01:12.033 --> 00:01:14.937
Is this query going to work
or is there a problem here

00:01:19.983 --> 00:01:21.871
Who sees the table numbers

00:01:22.014 --> 00:01:23.647
I'll show him again maybe

00:01:23.808 --> 00:01:25.530
He has the column max_num

00:01:25.967 --> 00:01:27.474
And the values 1 2 3

00:01:27.632 --> 00:01:28.949
That's the table numbers

00:01:29.717 --> 00:01:33.209
So if you look at this query, is there
a problem or is it going to work?

00:01:34.050 --> 00:01:35.264
What do you guys think?

00:01:45.117 --> 00:01:47.188
Maybe it's a little difficult
to answer that question

00:01:47.343 --> 00:01:50.358
But do you understand conceptually
what it says here in the FROM

00:01:50.484 --> 00:01:52.819
What is the first step that
happens in the FROM

00:01:55.283 --> 00:01:57.333
It's always the same step,
because there's a comma

00:01:57.459 --> 00:01:59.069
So the first step is a...

00:02:00.899 --> 00:02:03.382
Cross Join, good Filip! Cross Join

00:02:04.220 --> 00:02:08.183
Not explicitly stated, so we speak
abstractly of a carthesian product

00:02:08.587 --> 00:02:10.087
numbers is 1 2 3

00:02:10.350 --> 00:02:12.217
But what does that second table say

00:02:13.617 --> 00:02:15.217
What does it say

00:02:19.700 --> 00:02:22.017
Could you think conceptually

00:02:22.395 --> 00:02:24.968
We haven't seen that yet, but
conceptually you might be able to think

00:02:25.094 --> 00:02:27.189
I think something like that is going to be in there

00:02:31.967 --> 00:02:34.536
generate_series just starts with value 1

00:02:34.739 --> 00:02:36.571
And it stops at value max_num

00:02:36.697 --> 00:02:39.101
And max_num was a column from numbers

00:02:40.017 --> 00:02:41.117
So

00:02:42.127 --> 00:02:43.630
A list from 1 to max_num

00:02:43.804 --> 00:02:45.763
Indeed Sigfried, but what is this max_num?

00:02:46.198 --> 00:02:49.221
max_num comes from numbers,
so what do you expect there

00:02:51.867 --> 00:02:53.160
Very good Jarne, yes

00:02:53.333 --> 00:02:54.666
So you are indeed expecting

00:02:54.967 --> 00:02:56.363
Numbers is once 1

00:02:57.100 --> 00:03:00.325
The max_num of numbers is one
times 1, so I expect once (1, 1)

00:03:00.717 --> 00:03:02.900
Numbers is one time 2

00:03:03.026 --> 00:03:04.216
The next row in it

00:03:04.342 --> 00:03:07.104
So I expect one time
generate_series from 1 to 2

00:03:07.551 --> 00:03:08.670
And numbers is one time 3

00:03:08.796 --> 00:03:11.575
The last row, so I expect to
generate_series from 1 to 3

00:03:13.300 --> 00:03:16.212
This is what you can conceptually
can think of, so that's good.

00:03:16.389 --> 00:03:19.768
This is going to be a problem,
he's going to say look, um

00:03:21.458 --> 00:03:23.752
That doesn't work, because I
find my max_num

00:03:24.397 --> 00:03:28.340
And he sees that - he knows - he realizes
look that's present in the table numbers

00:03:28.466 --> 00:03:31.976
But you can't refer to that
because that's on the same level

00:03:32.193 --> 00:03:34.148
You can't be at the same level in the FROM

00:03:34.355 --> 00:03:35.561
That's not possible

00:03:35.987 --> 00:03:38.599
What kind of construction does
this remind us of?

00:03:38.798 --> 00:03:41.377
With what we saw in the
first semester

00:03:42.233 --> 00:03:44.367
That max_num comes from somewhere else

00:03:45.761 --> 00:03:47.729
So when you think about
subquerries, what kind of

00:03:47.933 --> 00:03:51.658
This is not a subquerry, but what
kind of subquerry does this remind you of then?

00:03:56.300 --> 00:03:58.799
Because I have a dependency here

00:04:02.254 --> 00:04:04.245
Indeed Kim, a correlated subquerry

00:04:04.621 --> 00:04:07.404
So we can indeed do something like
do like correlated subquerries

00:04:07.530 --> 00:04:09.673
But then indeed we have to

00:04:10.194 --> 00:04:11.503
Solve this little problem

00:04:11.901 --> 00:04:14.124
And we do that by using lateral

00:04:14.754 --> 00:04:16.747
So lateral when we have a
subquerry or a

00:04:17.133 --> 00:04:18.508
Part in the table in the FROM

00:04:19.134 --> 00:04:22.741
And we want to refer to another
part in the FROM that comes before it

00:04:22.948 --> 00:04:24.709
Then we use lateral

00:04:25.500 --> 00:04:27.697
To say lateral - at
the same level as will

00:04:28.088 --> 00:04:29.188
Lateral

00:04:29.889 --> 00:04:32.228
So that's how we can actually
start creating those references

00:04:32.354 --> 00:04:33.553
So that previous query

00:04:34.933 --> 00:04:36.488
This is in more detail of course

00:04:37.185 --> 00:04:38.391
So just to sum it up

00:04:39.356 --> 00:04:42.886
So you can refer to a previous
table reference - like numbers

00:04:43.012 --> 00:04:46.274
You can refer to a previous subquery
(if there is a subquery in the FROM)

00:04:46.560 --> 00:04:48.441
Or you can refer to a function

00:04:48.703 --> 00:04:51.502
Which returns a set,
a set returning function

00:04:51.628 --> 00:04:53.313
So a function that returns a
collection

00:04:53.654 --> 00:04:55.876
generate_series is one example.

00:04:59.277 --> 00:05:01.427
In the standard

00:05:02.183 --> 00:05:05.847
It's even allowed when
there is a set returning function

00:05:05.973 --> 00:05:08.731
Of possibly leaving that out -
so I put that there differently

00:05:08.893 --> 00:05:10.875
Had had numbers not been a table, but a

00:05:11.130 --> 00:05:13.621
Set returning function, then
I could have done that as well

00:05:14.117 --> 00:05:15.974
But I don't recommend this last bit

00:05:16.590 --> 00:05:19.391
Because that can be a little confusing,
it's just so you know [that it exists]

00:05:19.775 --> 00:05:23.825
So if you're referring at the same
level, just put lateral

00:05:24.465 --> 00:05:27.469
But with set returning functions
you can leave it out

00:05:28.833 --> 00:05:30.682
So I put my lateral here

00:05:31.248 --> 00:05:36.307
And from that moment on, I do indeed get
the results that Jarne predicted

00:05:36.641 --> 00:05:38.829
So I get 1 with 1

00:05:39.017 --> 00:05:40.495
2 is now my max_num here

00:05:40.833 --> 00:05:44.391
So I get 1 and 2 at generate_series
combined with those two

00:05:44.664 --> 00:05:46.664
And for 3 I get 1 2 3

00:05:49.083 --> 00:05:53.305
Now you can see that there is a
dependency in my FROM that I use

00:05:56.335 --> 00:05:58.287
So what I just said of look

00:05:59.000 --> 00:06:01.928
These two querries, because it is a generate

00:06:02.410 --> 00:06:04.805
A set generating function is

00:06:05.013 --> 00:06:08.351
Set returning function you can
indeed still use, but well

00:06:09.194 --> 00:06:10.972
Show the age of each customer

00:06:11.339 --> 00:06:13.719
There are several
ways to solve this

00:06:15.784 --> 00:06:18.014
You could do this
with a lateral join now

00:06:19.947 --> 00:06:23.067
We have customers, and here
we actually calculate per customer

00:06:23.937 --> 00:06:26.230
The age and we say look um

00:06:30.172 --> 00:06:33.989
This is of course a complicated construction
to solve something that is normally simpler

00:06:34.115 --> 00:06:36.615
Show per customer the age, how
would you normally do that?

00:06:37.633 --> 00:06:41.497
It's just a first example
to see that you still have alternatives

00:07:06.783 --> 00:07:10.399
Yeah indeed, you're just going to
calculate, retrieve that way

00:07:14.991 --> 00:07:18.670
Because we have - maybe
a little note - because we have a

00:07:19.527 --> 00:07:21.185
Join condition, left join

00:07:21.426 --> 00:07:22.820
He is expecting a join condition

00:07:23.229 --> 00:07:25.625
You can think for yourself

00:07:25.850 --> 00:07:27.382
What is going on with this join condition

00:07:27.705 --> 00:07:30.900
You could try a different join condition
and see what happens

00:07:31.319 --> 00:07:33.398
So you might want to try that out.

00:07:34.713 --> 00:07:35.813
So

00:07:35.939 --> 00:07:37.048
Indeed

00:07:37.181 --> 00:07:39.269
I actually gave it away:
is that join condition necessary?

00:07:39.395 --> 00:07:41.517
There's actually a carthesic
product being taken there

00:07:42.040 --> 00:07:44.332
So I might as well have
put: ON true

00:07:44.552 --> 00:07:45.956
Because if you go back

00:07:46.157 --> 00:07:48.728
There is no one who made the
remark, but age

00:07:48.936 --> 00:07:50.317
And date of birth

00:07:50.567 --> 00:07:52.167
And age over here

00:07:52.460 --> 00:07:54.621
Could I have put something else here?

00:07:56.027 --> 00:07:58.249
So basically just, that true here

00:07:58.720 --> 00:08:02.824
That's just because a join, by
definition expects a join condition

00:08:02.950 --> 00:08:04.817
Unless this is a
cross join of course

00:08:05.336 --> 00:08:06.436
So there you go

00:08:09.832 --> 00:08:11.498
This of course gives
the same result

00:08:11.624 --> 00:08:13.982
That's the cross join
that I actually use

00:08:16.626 --> 00:08:20.272
So, that carthesian product
as we have seen and um

00:08:20.629 --> 00:08:23.493
Jarne actually intuitively
felt at first

00:08:25.179 --> 00:08:27.178
That's actually how
you guys intuitively feel

00:08:27.313 --> 00:08:29.767
From subquerries, from
programming with a

00:08:29.919 --> 00:08:31.861
A loop that depends on another loop

00:08:32.183 --> 00:08:36.016
So usually we can add that
ON true

00:08:37.772 --> 00:08:39.452
So what kind of join

00:08:40.351 --> 00:08:41.462
Are you going to use

00:08:43.521 --> 00:08:46.165
That depends on you, so
you got that cross here, that inner

00:08:46.388 --> 00:08:49.060
Those are going to behave the same way, but

00:08:51.100 --> 00:08:52.745
The carthesian product itself

00:08:52.871 --> 00:08:54.753
So that continues to behave the same way

00:08:54.928 --> 00:08:57.274
Now you use left or right or full

00:08:57.538 --> 00:09:00.480
Then any data that was missing
may be filled in

00:09:00.606 --> 00:09:02.669
That may have been filtered out

00:09:07.250 --> 00:09:08.836
We can actually start choosing here

00:09:13.493 --> 00:09:16.483
You can work with a cross
join, you can work with an inner join

00:09:16.609 --> 00:09:18.513
Or we can write that down simply by

00:09:18.864 --> 00:09:21.209
Directly putting a comma there

00:09:21.723 --> 00:09:23.269
So those are all options that you have

00:09:23.585 --> 00:09:25.291
Which actually in this case

00:09:25.629 --> 00:09:27.105
Are going to behave the same way

00:09:28.689 --> 00:09:31.589
Now if we're going to take a look at this here

00:09:32.127 --> 00:09:33.436
Then we have something else written here

00:09:34.010 --> 00:09:35.690
Take a look at it

00:09:51.067 --> 00:09:52.717
Does anyone see the difference?

00:09:53.014 --> 00:09:55.914
Where that the difference is made

00:10:13.200 --> 00:10:16.283
I said, if we work with cross join or inner join

00:10:16.550 --> 00:10:18.550
That is actually the same as the comma

00:10:19.200 --> 00:10:20.800
But here something else is going on

00:10:20.800 --> 00:10:22.800
And if sometimes people think, I can

00:10:22.800 --> 00:10:24.400
then why are they different

00:10:24.600 --> 00:10:25.960
These two queries

00:10:46.900 --> 00:10:48.900
You're sitting there with an on condition

00:10:49.267 --> 00:10:51.767
So in the second one, another on condition is added

00:10:51.767 --> 00:10:52.967
Which is not about an equality

00:10:52.980 --> 00:10:56.730
If you think about the relationship that is being calculated here

00:10:56.800 --> 00:10:58.200
So then we refer to that table here, k

00:10:58.783 --> 00:11:00.317
So those things have to match

00:11:00.350 --> 00:11:05.584
So it must be about that name and that birth date coming from k

00:11:05.600 --> 00:11:08.450
Here it is, but you get that filter as well

00:11:16.767 --> 00:11:18.834
So, what you get is from

00:11:20.030 --> 00:11:21.030
Avoid this

00:11:22.600 --> 00:11:26.717
Every right join can be written as a left join

00:11:26.720 --> 00:11:31.300
There are even databases, mysql has not had a right outer join for a long time

00:11:33.570 --> 00:11:36.033
Of course, you can always try to rewrite that as a left outer join

00:11:36.330 --> 00:11:38.167
So the same with that FULL there

00:11:38.217 --> 00:11:41.609
Because the behaviour is indeed not well defined

00:11:42.500 --> 00:11:44.200
So basically you can say

00:11:44.250 --> 00:11:49.667
I have here either a cross join which behaves
like an inner join with an equality

00:11:49.833 --> 00:11:51.867
Like the relationship that is established

00:11:53.017 --> 00:11:57.033
I could possibly specify an additional join condition
that is not about equality

00:11:57.817 --> 00:12:01.067
Then I get a different kind of behaviour,
or I could possibly work with an outer join

00:12:01.170 --> 00:12:07.717
A left outer join with any data that is not present
is present in my dependent part

00:12:08.967 --> 00:12:13.367
To add, from my original
first set table

00:12:18.017 --> 00:12:21.217
Again this should go pretty fast now

00:12:22.000 --> 00:12:30.100
I can simplify this quickly without needing the lateral there join
I can make it more performant

00:12:36.700 --> 00:12:43.633
What does lateral do? Lateral takes care of that k that is there
select age k, birth date that I can get that k

00:12:43.770 --> 00:12:48.283
That one is from customers, so I can get the birth date from it

00:12:48.550 --> 00:12:51.767
Without the word lateral the query is not executed.

00:12:52.500 --> 00:12:57.317
That k birth date, I can see that comes from customers
but I cannot refer to it

00:12:58.150 --> 00:13:01.967
Because the sql standard is defined there

0:13:03.900 --> 00:13:08.650
So that actually makes you analogous to the corralled subqueries
but they are on a lower level

00:13:09.267 --> 00:13:12.851
And here you can refer to something that is on the same level

00:13:14.000 --> 00:13:17.300
So how could this be simpler? I think that was said earlier

00:13:22.700 --> 00:13:24.933
I'm trying to see if everybody is awake

00:13:36.300 --> 00:13:38.967
They actually just calculate the date of birth for each customer.

00:13:39.650 --> 00:13:42.433
The age of the birth date, so just the age actually

00:13:45.117 --> 00:13:47.217
But how to do it more simply?

00:13:52.033 --> 00:13:54.400
Maybe Adam, what do you think?

00:14:05.000 --> 00:14:07.717
Indeed Kevin, no subquery, but just put in the select

00:14:08.100 --> 00:14:11.350
So star, age k birth date

00:14:15.230 --> 00:14:19.283
Indeed Milan, so this piece of age k point birth date you put in the select

00:14:19.883 --> 00:14:22.967
And then delete the rest of what comes after the word lateral

00:14:23.867 --> 00:14:25.333
So yes, fine

00:14:27.967 --> 00:14:35.867
Okay, there are a couple of cases where you say how can we use these lateral joins now

00:14:36.267 --> 00:14:41.083
Because in practice you're going to see, that you're trying to answer questions,
query questions

00:14:41.400 --> 00:14:44.350
When am I going to need it, and if you have problems having
to solve something

00:14:45.533 --> 00:14:48.083
When are you going to think about that lateral

00:14:48.317 --> 00:14:53.783
So it's about normalisation, so it's about a join
 condition that needs to be calculated

00:14:54.000 --> 00:14:56.300
Based on a column that is referred to

00:14:56.517 --> 00:15:02.500
Normalisation means an equalisation of the total sum of something
 from something that is calculated for that

00:15:02.733 --> 00:15:08.667
So, when you actually have subqueries that are dependent

00:15:09.450 --> 00:15:13.800
Subqueries that you want to use the result of
with dependencies

00:15:14.683 --> 00:15:18.033
So an example of normalisation for example

00:15:19.517 --> 00:15:22.667
So, suppose we have a table that is denormalized

00:15:23.067 --> 00:15:26.050
You've all had data modelling techniques

00:15:26.430 --> 00:15:31.183
So that's where we taught you normalisation the reverse way when 
we're going to merge tables

00:15:31.417 --> 00:15:36.533
So add together all possible combinations that are correct 
according to the dependencies

00:15:36.817 --> 00:15:41.900
So just a join between two tables actually,
is a de-normalisation you could say.

00:15:44.317 --> 00:15:47.467
Then we can use that for example

00:15:47.950 --> 00:15:56.283
So, let's say we have for example a denormalized
table, namely saying these are my ids

00:15:56.517 --> 00:15:59.317
They all correspond to other ids

00:16:00.030 --> 00:16:06.083
For example, I have here the row 1, 2, 3,
4, 5, 6 and this row

00:16:09.070 --> 00:16:13.517
So what does that mean if you think about how does this one look,
I don't know it by heart, yeah

00:16:13.800 --> 00:16:19.333
So this is denormalized, because normally what do you expect
in a normalized table, if for instance

00:16:19.567 --> 00:16:24.733
Intermediate table as you popularly call it,
what would it look like?

00:16:25.367 --> 00:16:35.833
So to say that id 1, player 1 for example refers to position 1,
player 1 refers to position 2 and player 1 also refers to position 3

00:16:35.983 --> 00:16:37.850
There is a link, there we know something of position and player

00:16:39.070 --> 00:16:42.967
Player 2 refers to position 4, player 2 also refers to position 5

00:16:43.383 --> 00:16:47.283
So how was this normally stored as you saw it

00:16:50.070 --> 00:16:54.350
If we have a table of players and a table of positions with
between them a many on many

00:16:57.000 --> 00:17:00.533
Then instead of 3 rows here, how many rows?

00:17:08.030 --> 00:17:12.200
To keep track, it is an abstract example here,
indeed Lucas, nine

00:17:12.500 --> 00:17:17.033
1 combined with 1, 1 with 2, 1 with 3,
that's the first 3 rows

00:17:17.200 --> 00:17:19.367
So this is denormalised

00:17:19.967 --> 00:17:23.650
So it's also annoying to have a, you can't say here:
it is an equal to

00:17:24.200 --> 00:17:26.167
It is an embarrassing join condition there

00:17:26.500 --> 00:17:32.517
So, what we're going to do is look euhmmm,
we're going to create a table parent

00:17:32.670 --> 00:17:36.133
So there will be that value 1, 2, 3

00:17:36.133 --> 00:17:42.200
Okay, and we're going to say, we refer to that,
we're sitting with eventual children

00:17:43.430 --> 00:17:47.033
A function that I can use now for example
to break this down

00:17:47.383 --> 00:17:54.217
Is unnest, so that means that when we have denormalized data,
you're going to run into them at some point

00:17:54.367 --> 00:17:58.917
But you will find that it is difficult to work with,
then you can normalise it again.

00:17:59.267 --> 00:18:06.067
And then attach it again, and take it apart with that function, unnest,
so we can convert a row like that

00:18:06.317 --> 00:18:08.233
So that it's all separate values again.

00:18:08.950 --> 00:18:10.800
So, what do I get?

00:18:11.183 --> 00:18:13.683
I had that denormalised table

00:18:14.317 --> 00:18:17.267
And in it were those 1 with 1, 2, 3

00:18:17.700 --> 00:18:20.550
that 2 with, I don't know, 2, 4, 5

00:18:22.230 --> 00:18:26.550
So those other ids that was that 1, 2, 3, that row of 1, 2, 3,
I'm going to unnest them here.

00:18:27.030 --> 00:18:29.133
So that would be 1, 2, 3 in a row.

00:18:29.417 --> 00:18:33.350
So if I join that, I'll get these
these results

00:18:33.750 --> 00:18:38.200
So basically, I get my normalized data back here

00:18:41.200 --> 00:18:44.350
Those 9 rows that Lucas predicted there as well

00:18:46.450 --> 00:18:48.067
So that is 1 possibility

00:18:48.170 --> 00:18:53.467
What does that mean, I did that query,
that's this query, to test whether this is working properly.

00:18:53.600 --> 00:18:59.400
I've got the data here, so I can actually go ahead and suggest to him a way
that they are normalised

00:18:59.500 --> 00:19:04.550
Instead of in a way that they are denormalised,
this is how they are stored now

00:19:04.867 --> 00:19:08.750
For me it's much more interesting that I store them this way

00:19:09.283 --> 00:19:13.783
So all I have to do is, this is a query,
I turn that query into an insert statement.

00:19:14.167 --> 00:19:18.450
By just putting insert in front of it, so insert into the table
that we've created

00:19:19.050 --> 00:19:22.733
So we put it in there

00:19:22.800 --> 00:19:25.367
So that's also something that you can do, which I think you've already figured out

00:19:25.750 --> 00:19:29.633
Insert you can use the values, insert into table, x values

00:19:30.017 --> 00:19:33.517
And then you sum up values, but you can just as well use a select statement there

00:19:33.767 --> 00:19:35.850
For example, to do an insert

00:19:38.050 --> 00:19:45.033
Okay, another case, so we've seen there the case of
normalization, denormalization

00:19:45.383 --> 00:19:50.783
A join condition that has to be calculated based on a
referenced column

00:19:52.270 --> 00:19:55.300
There are other ways to do this but this was about 1 example

00:19:55.667 --> 00:20:00.683
Imagine, you want to know all the people who have a common
 letters in their first name

00:20:00.710 --> 00:20:01.570
example

00:20:01.909 --> 00:20:05.770
my colleague, amie and i, wim there is the letter "m" in it

00:20:06.056 --> 00:20:08.703
so we have common letters in our first names.

00:20:09.170 --> 00:20:12.070
for example i see there

00:20:12.603 --> 00:20:14.217
lucas is the last one here

00:20:14.497 --> 00:20:17.217
lucas and my name have no common letters.

00:20:17.390 --> 00:20:18.430
lucas and milan do

00:20:19.980 --> 00:20:22.620
lucas and kevin don't either, for example

00:20:23.406 --> 00:20:26.713
I want to show people who have common letters in their first name

00:20:29.487 --> 00:20:31.587
We can use this for example.

00:20:32.513 --> 00:20:35.527
there is a function like a nest.

00:20:35.552 --> 00:20:38.010
so that we can convert strings to

00:20:38.223 --> 00:20:39.377
separate characters

00:20:39.530 --> 00:20:40.457
that's a first step

00:20:43.097 --> 00:20:45.443
so I can convert names and first names

00:20:45.754 --> 00:20:47.054
so think about it and we'll have that function.

00:20:47.400 --> 00:20:49.614
start converting first names to separate letters

00:20:51.394 --> 00:20:52.007
okay

00:20:53.654 --> 00:20:55.714
then we could actually use that

00:20:55.960 --> 00:20:58.167
then we could use this to get a name

00:20:58.293 --> 00:21:00.393
so like a table was just made

00:21:00.473 --> 00:21:01.987
from one row to the other

00:21:03.280 --> 00:21:04.813
then the corresponding values

00:21:06.277 --> 00:21:07.777
could you do that here

00:21:07.843 --> 00:21:09.270
to actually start combining the names

00:21:09.337 --> 00:21:10.577
with all their separate letters

00:21:10.863 --> 00:21:12.817
understands everybody, I'm going to let it stand for a moment

00:21:14.100 --> 00:21:14.840
for example

00:21:14.993 --> 00:21:16.580
image you are in a table customers state

00:21:16.600 --> 00:21:17.833
just the word

00:21:17.927 --> 00:21:18.600
arthur

00:21:18.873 --> 00:21:20.153
there is only one name

00:21:20.567 --> 00:21:22.360
customer number 1 with arthur

00:21:22.857 --> 00:21:24.484
What is shown here?

00:21:25.297 --> 00:21:26.710
what comes out of this query

00:21:26.735 --> 00:21:27.317
who can say

00:21:30.837 --> 00:21:33.297
image you in table customer has only one row

00:21:34.123 --> 00:21:36.163
called customer 1 rent

00:21:52.050 --> 00:21:54.223
will first ask another question

00:21:54.417 --> 00:21:56.223
how many rows are going to come out of this

00:21:56.857 --> 00:21:57.823
from this query

00:22:05.206 --> 00:22:06.193
one row

00:22:07.714 --> 00:22:09.340
people who have any other ideas?

00:22:12.287 --> 00:22:13.600
remember in there

00:22:14.360 --> 00:22:15.454
you've got something like

00:22:15.520 --> 00:22:16.494
a cartesian product

00:22:16.684 --> 00:22:18.684
but with that dependence from here

00:22:18.924 --> 00:22:19.604
so that

00:22:19.770 --> 00:22:20.657
arthur

00:22:21.070 --> 00:22:23.284
who is going to be on that "k1.vname"

00:22:24.124 --> 00:22:25.230
indeed mathias

00:22:25.910 --> 00:22:26.990
have you got any ideas

00:22:27.103 --> 00:22:28.423
use your microphone.

00:22:28.503 --> 00:22:29.843
what the output is

00:22:31.063 --> 00:22:31.843
at arthur

00:22:41.943 --> 00:22:45.317
otherwise the first row only, if you just put it in the chat

00:22:48.526 --> 00:22:50.666
then the other 6 rows will follow automatically I think.

00:22:56.350 --> 00:22:57.903
yes, that's right

00:22:57.943 --> 00:22:59.583
we get there 6 times artuur

00:22:59.903 --> 00:23:01.836
because artuur consists of 6 letters.

00:23:02.074 --> 00:23:04.740
so this here this second expression here

00:23:04.934 --> 00:23:07.627
select regexp_split_to_table

00:23:08.334 --> 00:23:10.474
function that splits the name

00:23:10.766 --> 00:23:12.226
into separate characters

00:23:12.313 --> 00:23:14.360
Then I get a,r,t and so on.

00:23:14.546 --> 00:23:15.253
six letters

00:23:15.766 --> 00:23:16.900


00:23:16.933 --> 00:23:15.613
so I get a table here

00:23:17.360 --> 00:23:18.720
with six rows

00:23:18.786 --> 00:23:20.486
which is combined with a row

00:23:20.533 --> 00:23:21.973
from that top one so I get

00:23:22.007 --> 00:23:23.067
six rows in all

00:23:23.180 --> 00:23:24.660
so I get arthur a

00:23:25.073 --> 00:23:26.013
rent r

00:23:26.373 --> 00:23:27.400
ground rent t

00:23:27.707 --> 00:23:29.907
etcover to final arrent r

00:23:33.359 --> 00:23:35.293
that's one way, everybody understands why I do that.

00:23:36.353 --> 00:23:39.726
to actually cross over with people with the same

00:23:39.960 --> 00:23:41.260
letter in their name have

00:23:42.253 --> 00:23:44.036
Now I've actually created a table where

00:23:44.116 --> 00:23:44.783
by name

00:23:44.976 --> 00:23:46.603
knows which letter occurs in

00:23:46.783 --> 00:23:48.530
so what could be the next step

00:23:48.956 --> 00:23:50.383
at what level are you going to think

00:23:55.450 --> 00:23:57.936
so I have that here for example for arthuur we know that

00:23:58.750 --> 00:24:01.943
but if it had to be someone else e.g. lucas i would have five rows here

00:24:02.990 --> 00:24:05.630
Then those l, u and so on.

00:24:06.327 --> 00:24:08.007
Then at some point we get the letter "a".

00:24:09.647 --> 00:24:11.767
so what could you start using as

00:24:12.347 --> 00:24:15.087
being a . . condition

00:24:38.843 --> 00:24:42.070
so the first time you guys have worked with that letter already

00:24:43.016 --> 00:24:44.083
is a little bit of getting used to.

00:24:47.523 --> 00:24:48.856
if you go one step further

00:24:50.027 --> 00:24:51.980
so that conversion, as just put

00:24:52.013 --> 00:24:53.100
it does happen.

00:24:53.206 --> 00:24:55.053
that arthur, here it is about sjeik

00:24:55.107 --> 00:24:56.420
etcetera so all the

00:24:57.066 --> 00:24:59.153
all the elements are actually

00:24:59.180 --> 00:25:00.640
normally only one row for Sheikh

00:25:00.753 --> 00:25:01.833
I now have 5.

00:25:02.093 --> 00:25:02.940
etcetera

00:25:03.066 --> 00:25:04.366
so I get all these people

00:25:06.166 --> 00:25:07.573
so if I have this as a table

00:25:08.373 --> 00:25:09.706
how would I now make that table

00:25:09.813 --> 00:25:11.346
connect to itself?

00:25:12.993 --> 00:25:13.873
such that

00:25:14.140 --> 00:25:15.586
I get all the people

00:25:15.733 --> 00:25:18.506
who have a common letter in their first name

00:25:19.213 --> 00:25:20.913
how can I make that table with itself

00:25:21.020 --> 00:25:22.120
imagine that is a table

00:25:23.390 --> 00:25:24.930
with customer number first name l

00:25:25.350 --> 00:25:27.530
How do I connect that table to itself so that I can

00:25:27.763 --> 00:25:28.463
all the people

00:25:29.156 --> 00:25:31.910
together who have a common letter

00:25:31.935 --> 00:25:32.806
have in their first name

00:25:40.573 --> 00:25:41.346
what is then

00:25:42.546 --> 00:25:43.666
my joined condition

00:25:45.246 --> 00:25:48.606
so imagine i'm going to call up that table twice for example

00:25:52.390 --> 00:25:54.390
what is this join condition going to be.

00:25:54.924 --> 00:25:55.984
This is the table.

00:25:56.530 --> 00:25:57.744
x1

00:25:57.890 --> 00:26:00.037
And I call table x2 again.

00:26:00.110 --> 00:26:02.364
but that's actually the same table so how can I call x1 and x2

00:26:02.653 --> 00:26:04.247
going to connect on which column

00:26:07.553 --> 00:26:09.827
are going to merge, are going to join

00:26:21.190 --> 00:26:23.190
yes indeed, so that "L"

00:26:23.610 --> 00:26:25.629
but not even a like is necessary

00:26:25.737 --> 00:26:26.743
because it's a character

00:26:27.717 --> 00:26:29.316
so I'm going to use that "L"

00:26:29.343 --> 00:26:30.457
That's right, milan.

00:26:30.564 --> 00:26:31.844
x1 l, x2 l

00:26:31.950 --> 00:26:32.984
so that system

00:26:33.210 --> 00:26:35.250
so those are the steps that I've done here

00:26:35.697 --> 00:26:36.597
we are indeed going to

00:26:36.837 --> 00:26:38.484
so we want to know per person

00:26:39.850 --> 00:26:41.177
common letter

00:26:41.202 --> 00:26:43.564
so initially I want to know who has a common letter

00:26:44.404 --> 00:26:45.477
then I can just

00:26:45.557 --> 00:26:46.724
maybe start counting again

00:26:46.749 --> 00:26:47.564
because that's a step deeper

00:26:47.610 --> 00:26:48.830
but I'm the problem

00:26:48.873 --> 00:26:50.053
we are breaking this down

00:26:50.257 --> 00:26:51.937
so the join condition is indeed

00:26:51.997 --> 00:26:53.190
are indeed the common letters

00:26:53.717 --> 00:26:55.217
that is, I have those customers

00:26:56.057 --> 00:26:57.857
and I'm actually going to split them up

00:26:59.000 --> 00:27:00.233
in the first time

00:27:00.540 --> 00:27:02.626
i'm going to split those clats a second time

00:27:02.800 --> 00:27:03.626
that's good.

00:27:04.266 --> 00:27:05.673
Then I get all these letters.

00:27:06.406 --> 00:27:08.553
I'm going to say they must have the same letters

00:27:09.013 --> 00:27:10.420
that's that where condition here

00:27:11.773 --> 00:27:13.206
and I'm also going to say

00:27:13.906 --> 00:27:16.240
I'm going to say it must be other people

00:27:16.393 --> 00:27:18.746
cause I want to know what other people have gmn. letters

00:27:19.714 --> 00:27:23.834
because it doesn't make sense to say arthur has the same letters as arthur

00:27:24.200 --> 00:27:25.586
customer 1 goes

00:27:27.820 --> 00:27:28.700
so hence

00:27:29.706 --> 00:27:32.673
the condition after building that structure

00:27:33.283 --> 00:27:35.930
have a letter in common but are not the same client

00:27:41.380 --> 00:27:43.060
here we are.

00:27:44.780 --> 00:27:46.020
Now I have to know

00:27:47.653 --> 00:27:49.206
so the question was

00:27:51.413 --> 00:27:53.487
we want to know how many people are there

00:27:53.580 --> 00:27:55.087
that's what all students would have

00:27:55.453 --> 00:27:58.213
how many people are there who have one letter in common

00:27:58.247 --> 00:27:58.893
with arthur

00:27:59.290 --> 00:28:00.997
how many people are there who have one letter in common

00:28:01.090 --> 00:28:02.930
with milan and so on.

00:28:03.570 --> 00:28:05.577
how can i solve this problem

00:28:05.617 --> 00:28:06.530
if I have this query

00:28:15.277 --> 00:28:16.843
are almost to the solution

00:28:29.254 --> 00:28:30.720
so this query is going

00:28:31.870 --> 00:28:33.450
give for each person

00:28:34.043 --> 00:28:35.723
other people who have a letter

00:28:35.770 --> 00:28:36.970
in common outside of themselves

00:28:38.283 --> 00:28:39.796
how should i make this query yet

00:28:40.260 --> 00:28:42.047
adjust a little bit, expand to know

00:28:42.313 --> 00:28:43.480
how many people there are

00:28:44.080 --> 00:28:45.540
who have a letter in common

00:28:45.627 --> 00:28:48.100
with your name or with the name of the person

00:28:49.240 --> 00:28:50.207
that's on that row

00:28:52.947 --> 00:28:53.973
that group by

00:28:57.807 --> 00:29:00.413
is customer 1 name and customer 2 name

00:29:00.447 --> 00:29:01.893
are those functionally dependent on that

00:29:02.140 --> 00:29:03.700
you have to think about that

00:29:07.280 --> 00:29:07.860
so

00:29:10.427 --> 00:29:11.460
we'll get there I think

00:29:13.537 --> 00:29:15.044
That's right, the group by and the count.

00:29:15.270 --> 00:29:17.144
so don't get caught by

00:29:17.169 --> 00:29:18.317
that k2 name

00:29:18.457 --> 00:29:19.764
if that has any other value

00:29:19.789 --> 00:29:20.930
you're going to get error messages there.

00:29:21.204 --> 00:29:22.750
so indeed there but just a

00:29:22.857 --> 00:29:23.630
grouping

00:29:24.537 --> 00:29:26.917
These are the results of that, for example.

00:29:29.370 --> 00:29:30.924
I wanted to first

00:29:31.347 --> 00:29:33.487
an alternative without lateral

00:29:35.780 --> 00:29:37.473
without lateral do this

00:29:37.600 --> 00:29:38.987
are you actually going to be working with subquerys

00:29:39.012 --> 00:29:40.816
if you're going to calculate the results separately

00:29:41.303 --> 00:29:42.803
so you go for example here

00:29:42.863 --> 00:29:44.216
harrow from

00:29:44.376 --> 00:29:46.583
I'm going to break those names down this is one table

00:29:46.890 --> 00:29:48.343
so that program

00:29:48.376 --> 00:29:49.610
then I can repeat

00:29:51.443 --> 00:29:52.730
so without lateral

00:29:52.803 --> 00:29:54.330
does that mean that all of that moves

00:29:54.376 --> 00:29:55.636
to you select statement

00:29:56.137 --> 00:29:58.110
so I get the same query as before.

00:29:58.270 --> 00:29:59.357
but I'm going to do all those things
00:29:59,721 --&gt; 00:30:02,248
so put it here in my front. I'm going to put those
00:30:02,267 --&gt; 00:30:05,506
take a look, so I calculated those here separately actually.
00:30:05,540 --&gt; 00:30:09,120
So this is also an option I just wanted to show.
00:30:09,180 --&gt; 00:30:11,280
all, let's see. I was thinking.
00:30:11,523 --&gt; 00:30:14,410
we'll..., it's true what you guys say hey, the GROUP BY and the COUNT.
00:30:14,435 --&gt; 00:30:17,576
I expected the solution after that, I don't have my preview on.
00:30:18,137 --&gt; 00:30:19,137
okay
00:30:20,000 --&gt; 00:30:23,509
So if we just adjust this query
00:30:23,534 --&gt; 00:30:26,821
To finalize it because apparently that slide is missing.
00:30:28,367 --&gt; 00:30:30,917
Indeed, we're going to group those by customer number.
00:30:32,013 --&gt; 00:30:35,506
That name is functionally dependent so you can put that in your GROUP BY as well.
00:30:35,526 --&gt; 00:30:38,787
Indeed, you just get a COUNT that you can put in there.
00:30:38,814 --&gt; 00:30:41,980
So you can say GROUP BY customer number and first name.
00:30:42,007 --&gt; 00:30:44,693
and you should leave out the k2 name
00:30:44,793 --&gt; 00:30:47,586
or you're going to do count of k2 name by.
00:30:47,713 --&gt; 00:30:50,066
So you can do that perfectly then.
00:30:50,213 --&gt; 00:30:54,233
We don't need that L1 anymore to see what the common initial is.
00:30:54,258 --&gt; 00:30:56,316
um, the common letter.
00:30:56,363 --&gt; 00:30:58,663
So that's just here for your information.
00:30:59,930 --&gt; 00:31:07,453
And then the other little example I just said hey, so without a letter we can also possibly work if we calculate those things separately.
00:31:08,360 --&gt; 00:31:09,360
okay.
00:31:10,536 --&gt; 00:31:14,130
Then we have another little example.
00:31:14,397 --&gt; 00:31:16,290
Non-scalar subqueries
00:31:16,943 --&gt; 00:31:20,129
What do we mean by a scalar subquery?
00:31:24,740 --&gt; 00:31:27,913
Remember? We had 4 types of subqueries.
00:31:28,167 --&gt; 00:31:30,186
We had table subqueries,
00:31:30,353 --&gt; 00:31:31,393
we had...
00:31:34,317 --&gt; 00:31:36,592
Abstractly, it's always a table of course,
00:31:36,617 --&gt; 00:31:39,721
but for certain dimentions we give it a different name.
00:31:40,047 --&gt; 00:31:44,340
So what do we mean by a scalar subquery?
00:31:46,246 --&gt; 00:31:51,570
Multiple rows and columns? Then we talk about a table subquery Lucas.
00:31:51,667 --&gt; 00:31:57,407
NIet-scalar, then we mean by that it is more than 1 row and 1 column.
00:31:57,503 --&gt; 00:31:59,803
So that's not scalar there.
00:32:00,263 --&gt; 00:32:02,529
So scalar subquery is just 1 times 1.
00:32:02,897 --&gt; 00:32:03,269
yes.
00:32:03,460 --&gt; 00:32:06,532
but we're talking about
non scalar subqueries
00:32:06,563 --&gt; 00:32:11,519
Subqueries that we know of that are not scalar.
00:32:11,560 --&gt; 00:32:14,093
You guys also know that if we put a subquery in the SELECT...
00:32:14,706 --&gt; 00:32:17,763
In the Select, yes then there should only be 1 value there.
00:32:18,137 --&gt; 00:32:23,570
If it says "SELECT customer number comma" there and then a subquery, only 1 value should come out of that.
00:32:23,684 --&gt; 00:32:28,990
that should be there, that's the only way you can add that in the SELECT, but what if it's not...
00:32:29,430 --&gt; 00:32:32,273
That then more than 1 value, how do we solve that?
00:32:33,830 --&gt; 00:32:34,830
Okay
00:32:34,896 --&gt; 00:32:35,896
So
00:32:36,296 --&gt; 00:32:37,296
This Here.
00:32:37,883 --&gt; 00:32:39,163
Is not a problem.
00:32:39,713 --&gt; 00:32:41,646
This is a Scalar subquery.
00:32:41,833 --&gt; 00:32:45,023
Hey, I'm looking up stuff here from travel,...
00:32:45,544 --&gt; 00:32:49,563
And I write a subquery in my SELECT and da maximum is 1 value.
00:32:49,820 --&gt; 00:32:52,053
And it's a correlated subquery.
00:32:52,120 --&gt; 00:32:53,253
By itself, no problem.
00:32:53,293 --&gt; 00:32:58,366
is it correlated or not, the important thing is that there is only one value here, so it executes perfectly.
00:32:58,399 --&gt; 00:33:03,773
You always have to keep in mind, does that take the form of a table, does that make sense?
00:33:04,460 --&gt; 00:33:05,980
So this is not a problem, but....
00:33:07,313 --&gt; 00:33:08,806
What if I put this now?
00:33:09,313 --&gt; 00:33:11,666
Then you will indeed get that error message.
00:33:13,910 --&gt; 00:33:17,090
That length of stay, that could be multiple lengths of stay here.
00:33:17,160 --&gt; 00:33:21,460
For the same trip they are probably multiple visits so also multiple lengths of stay.
00:33:21,970 --&gt; 00:33:22,443
so
00:33:22,896 --&gt; 00:33:26,676
Here comes trip 1 with 7 different verbiage.
00:33:26,693 --&gt; 00:33:32,209
Now you can think of yes, to me that makes sense. I can go back and supplement that like that latteral. But that's not how that works.
00:33:32,393 --&gt; 00:33:35,061
The standard is not so defined.
00:33:35,086 --&gt; 00:33:37,539
So it always expects 1 value there.
00:33:38,367 --&gt; 00:33:40,100
So then you get that error.
00:33:40,780 --&gt; 00:33:43,593
So how can we solve that? also with that latteral again.
00:33:43,967 --&gt; 00:33:44,967
so euh...
00:33:46,324 --&gt; 00:33:48,223
Aja this little example I can also give.
00:33:54,700 --&gt; 00:34:00,520
It should really be 1 times 1 for subquery, because here only 1 comes out, they are also agregation functions, comes out 1 row
00:34:00,620 --&gt; 00:34:02,300
but with 2 columns
00:34:02,327 --&gt; 00:34:07,050
You could of course solve this by splitting that into 2 correlated subqueries. 1 for sum,
00:34:07,144 --&gt; 00:34:08,744
1note for variance.
00:34:09,494 --&gt; 00:34:10,494
but okay.
00:34:11,767 --&gt; 00:34:14,026
Just show it for the sake of completeness for the people who...
00:34:14,133 --&gt; 00:34:16,667
That's a question I get sometimes.
00:34:16,680 --&gt; 00:34:18,986
So the solution here is lateral eh.
00:34:19,056 --&gt; 00:34:20,576
Yes, we're going to have our...
00:34:20,616 --&gt; 00:34:24,904
The thing that was in our SELECT we're going to move to our FROM.
00:34:25,103 --&gt; 00:34:26,936
We say we want all those trips.
00:34:27,170 --&gt; 00:34:33,042
But in addition to those trips, we want to take a look at each trip, what about the length of stay here, both the sum and the variance.
00:34:33,174 --&gt; 00:34:35,113
For that trip, and I'll add that.
00:34:35,247 --&gt; 00:34:37,120
And I'm going to show that then.
00:34:37,480 --&gt; 00:34:41,430
The word lateral is needed here because length of stay comes from travel.
00:34:42,484 --&gt; 00:34:45,150
From the table travel at one level higher.
00:34:45,587 --&gt; 00:34:46,587
okay
00:34:48,360 --&gt; 00:34:51,027
So then we get this here for example.
00:34:51,150 --&gt; 00:34:52,950
We get here variance 0
00:34:53,060 --&gt; 00:34:59,040
Yes, that means there is only 1 visit for that trip. 31
00:34:59,746 --&gt; 00:35:00,746
okay
00:35:06,947 --&gt; 00:35:12,176
We could also write that query just now, the first one I gave there without those aggregation functions.
00:35:12,206 --&gt; 00:35:14,690
If we have more than one value, we can do that too.
00:35:15,813 --&gt; 00:35:16,279
yes
00:35:16,787 --&gt; 00:35:21,730
Now these are a little bit of artificial examples. because of course we can also start doing this by....
00:35:21,990 --&gt; 00:35:24,934
visits moving up a level.
00:35:24,964 --&gt; 00:35:27,097
And start calculating those things.
00:35:27,980 --&gt; 00:35:28,980
okay
00:35:29,374 --&gt; 00:35:32,174
We can make combinations of those things.
00:35:32,323 --&gt; 00:35:34,956
That is, you can both...
00:35:36,050 --&gt; 00:35:38,450
Work with either that latteral.
00:35:38,504 --&gt; 00:35:44,333
We can start working with even agregation functions combined with an ordinary value, so that GROUP BY.
00:35:44,460 --&gt; 00:35:46,713
So you can actually start doing a fair amount of those things.
00:35:48,307 --&gt; 00:35:48,846
okay
00:35:52,437 --&gt; 00:35:54,237
This might be another one.
00:35:54,577 --&gt; 00:35:56,177
That I can show then.
00:35:56,540 --&gt; 00:35:59,868
So, you guys have already seen different agregation functions,
00:36:01,290 --&gt; 00:36:03,243
let's go back, yeah.
00:36:07,340 --&gt; 00:36:08,340
moment
00:36:08,647 --&gt; 00:36:11,247
Now that example is no longer there, that's okay.
00:36:11,540 --&gt; 00:36:14,659
So the COUNT you all know.
00:36:14,913 --&gt; 00:36:19,150
but what we just did with that UN NEST
00:36:19,470 --&gt; 00:36:20,856
so from a row
00:36:21,360 --&gt; 00:36:25,313
flat hey, back to normalizing the original value.
00:36:25,493 --&gt; 00:36:31,099
Can you also reverse denormalize with an agregation cucntion like array agregate, so then we put those together
00:36:31,260 --&gt; 00:36:34,160
So das also a way that you can work.
00:36:34,760 --&gt; 00:36:38,408
So then you get something like that, the reverse effect actually.
00:36:39,980 --&gt; 00:36:45,046
Then the most common case I think, so all the previous cases we've seen so far
00:36:45,167 --&gt; 00:36:49,136
Unless you're really with such a normlization/denormalization problem.
00:36:49,690 --&gt; 00:36:54,329
So that it's denormalized data that you have to go and normalize.
00:36:56,250 --&gt; 00:37:00,826
Most of the queries that we've seen so far you can probably find another alternative.
00:37:00,860 --&gt; 00:37:02,873
That you don't need that lateral, yes.
00:37:03,254 --&gt; 00:37:09,250
This is one where that lateral usually, yeah,...you're not going to be able to get around it usually.
00:37:09,706 --&gt; 00:37:12,606
So, we just saw the presentation of fetch first.
00:37:12,653 --&gt; 00:37:15,753
So we want to start comparing that to a limited dependent result.
00:37:16,100 --&gt; 00:37:17,780
So what does that mean?
00:37:18,366 --&gt; 00:37:19,366
okay
00:37:20,460 --&gt; 00:37:23,646
So,this is such an example? we have travel....
00:37:24,616 --&gt; 00:37:29,339
And we're going to join that with this subquery but there's a dependency there with that leteral.
00:37:29,687 --&gt; 00:37:32,887
So try to see once, what does this query do?
00:39:41,290 --&gt; 00:39:45,106
Ah sorry, I had turned my sound off for a moment with the drinking.
00:39:45,233 --&gt; 00:39:47,373
Good that Sasha reports that.
00:39:48,000 --&gt; 00:39:52,076
So, the hint from Rik indeed,
00:39:52,636 --&gt; 00:39:57,796
or the thing that Arthuur says there or Rik, it's about the 2 smallest or the 2 largest indeed.
00:39:58,506 --&gt; 00:40:02,410
So if we go through it step by step, we have the table travel here in the FROM.
00:40:02,970 --&gt; 00:40:06,022
All the trips are shown anyway, here, LEFT.
00:40:06,800 --&gt; 00:40:09,516
Then that's combined with any visits.
00:40:09,656 --&gt; 00:40:12,262
I see that in visits B2
00:40:13,016 --&gt; 00:40:15,516
And the WHERE condition here, it goes for this trip.
00:40:16,647 --&gt; 00:40:18,187
So the visitor of that trip.
00:40:19,173 --&gt; 00:40:22,673
And for visiting I'm going to look up, what sky objects are actually visited here?
00:40:22,737 --&gt; 00:40:26,310
And then I'm going to sort them by diameter, just the first 2....
00:40:27,170 --&gt; 00:40:29,076
show and retrieve.
00:40:29,204 --&gt; 00:40:33,702
So that basically means, I'm going to per trip only the first 2 objects....
00:40:34,410 --&gt; 00:40:36,433
Which are visited according to the diameter.
00:40:36,526 --&gt; 00:40:40,066
Now the question is of course how is this sorted? ORDER BY diameter.
00:40:40,296 --&gt; 00:40:42,469
Is that from small to large or from large to small?
00:40:42,836 --&gt; 00:40:49,770
If you don't remember that, is not a problem, I don't always do that either but that is indeed the system that is applied here, we will have a look.
00:40:51,330 --&gt; 00:40:51,830
okay
00:40:52,110 --&gt; 00:40:55,770
So what you see here I think when you see those diameters going up.
00:40:55,943 --&gt; 00:40:58,682
You see here, after a 32 it does indeed go over.
00:40:58,956 --&gt; 00:41:02,969
So the 2 smallest celestial objects per trip that are shown here
00:41:04,107 --&gt; 00:41:05,107
okay
00:41:06,140 --&gt; 00:41:06,720
good
00:41:07,037 --&gt; 00:41:10,590
So by comparison, we'll look that one up.
00:41:11,050 --&gt; 00:41:13,009
This was line 32.
00:41:13,456 --&gt; 00:41:18,256
Did I have trip number 32, I had an object of diameter 7 and 14.
00:41:18,586 --&gt; 00:41:21,199
So if I look up everything for example from 32
00:41:22,294 --&gt; 00:41:26,420
I find there indeed so from 7, 14 and all those other are bigger.
00:41:26,680 --&gt; 00:41:30,787
So I effectively get the 2 smallest objects what are visited on that trip.
00:41:33,834 --&gt; 00:41:34,834
okay
00:41:35,240 --&gt; 00:41:42,180
So most of the time you can indeed work without that lateral, but some problems you can idly solve without that lateral.
00:41:42,247 --&gt; 00:41:44,780
So when you're sitting with an example like that....
00:41:46,413 --&gt; 00:41:47,613
Like this right here.
00:41:48,720 --&gt; 00:41:52,933
When that you actually have a... it stands here... moment...
00:41:53,370 --&gt; 00:41:56,603
When you have to compare to a limited dependent outcome.
00:41:56,756 --&gt; 00:41:59,902
So that you actually think for example, I need a subquery.
00:42:00,143 --&gt; 00:42:03,136
Where I need that fetch first while I'm in an edependency.
00:42:03,707 --&gt; 00:42:06,823
Then 9/10 you're going to need that lateral anyway.
00:42:07,184 --&gt; 00:42:11,919
Or you're stuck with that little example from earlier with that row that you want to start denormalizing.
00:42:12,034 --&gt; 00:42:14,434
The one you want to go normalize sorry.
00:42:14,560 --&gt; 00:42:19,799
Then 9/10 you're going to need a lateral like that as well although sometimes that does require alternatives.
00:42:20,113 --&gt; 00:42:23,802
Other than that, you can actually write alternative queries quite often.
00:42:24,603 --&gt; 00:42:27,186
Then the only question is, if you write those queries....
00:42:28,626 --&gt; 00:42:31,293
If you know how then you can do that.
00:42:31,886 --&gt; 00:42:39,062
I have that way with lateral, I have that way without lateral , we are going to compare those cost prices to see, which query do I choose here of course?
00:42:39,090 --&gt; 00:42:40,090
That's what we're trying to do to you guys...
00:42:40,413 --&gt; 00:42:45,786
so perfomance is something, once you master databases, then you really do get into that area of performance.
00:42:46,530 --&gt; 00:42:47,530
okay
00:42:47,710 --&gt; 00:42:50,177
Are there any questions about that lateral?
00:42:51,526 --&gt; 00:42:52,646
Lateral joins.
00:43:04,480 --&gt; 00:43:05,480
okay