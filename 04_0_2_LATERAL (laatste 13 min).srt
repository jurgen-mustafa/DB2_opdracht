1
00:29:59,721 --> 00:30:02,248
dus hier in mijn front zetten. Ik ga die dan

2
00:30:02,267 --> 00:30:05,506
even kijken, dus ik heb die hier appart berekent eigenlijk.

3
00:30:05,540 --> 00:30:09,120
Dus dit is ook een optie wou ik maar tonen.

4
00:30:09,180 --> 00:30:11,280
alle, even kijken. Ik dacht..

5
00:30:11,523 --> 00:30:14,410
we zullen..., het klopt wat jullie zeggen he, de GROUP BY en de COUNT.

6
00:30:14,435 --> 00:30:17,576
Ik had de oplossing daarna verwacht, ik heb mijn preview niet aan staan.

7
00:30:18,137 --> 00:30:19,137
oke

8
00:30:20,000 --> 00:30:23,509
Dus als we deze query nog even aanpassen

9
00:30:23,534 --> 00:30:26,821
om het af te ronden want blijkbaar ontbreekt die slide.

10
00:30:28,367 --> 00:30:30,917
Inderdaad, we gaan die groeperen op klantnummer.

11
00:30:32,013 --> 00:30:35,506
 Die naam is functioneel afhankelijk dus die kan je ook in je GROUP BY zetten.

12
00:30:35,526 --> 00:30:38,787
Je krijgt inderdaad gewoon een COUNT die je daar kan bij zetten.

13
00:30:38,814 --> 00:30:41,980
Dus je kan zeggen: GROUP BY klantnummer en voornaam.

14
00:30:42,007 --> 00:30:44,693
en die k2 naam moet je weglaten

15
00:30:44,793 --> 00:30:47,586
of je gaat count van k2 naam door doen.

16
00:30:47,713 --> 00:30:50,066
Dus dat kan je dan perfect doen.

17
00:30:50,213 --> 00:30:54,233
Die L1 hebben we niet meer nodig om te zien wat de gemeenschappelijke voorletter is.

18
00:30:54,258 --> 00:30:56,316
eh.., de gemeenschappelijke letter.

19
00:30:56,363 --> 00:30:58,663
Dus dat is hier maar ter informatie.

20
00:30:59,930 --> 00:31:07,453
En dan het andere voorbeeldje zei ik net he, dus zonder letter kunnen we ook eventueel werken als we die dingen appart berekenen.

21
00:31:08,360 --> 00:31:09,360
oke.

22
00:31:10,536 --> 00:31:14,130
Dan hebben we nog een ander voorbeeldje.

23
00:31:14,397 --> 00:31:16,290
Niet-scalaire subqueries

24
00:31:16,943 --> 00:31:20,129
Wat bedoelen we met een scalaire subquery?

25
00:31:24,740 --> 00:31:27,913
Weet je nog? We hadden 4 types van subqueries.

26
00:31:28,167 --> 00:31:30,186
We hadden tabel subqueries,

27
00:31:30,353 --> 00:31:31,393
we hadden...

28
00:31:34,317 --> 00:31:36,592
Abstract gezien is het altijd een tabel natuurlijk,

29
00:31:36,617 --> 00:31:39,721
maar voor beaalde dimenties geven we die een andere naam.

30
00:31:40,047 --> 00:31:44,340
Dus wat bedoelen we met een scalaire subquery?

31
00:31:46,246 --> 00:31:51,570
Meerdere rijen en kolommen? Dan spreken we van een tabel subquery Lucas.

32
00:31:51,667 --> 00:31:57,407
NIet-scalair, dan bedoelen we met dat het meer is dan 1 rij en 1 kolom.

33
00:31:57,503 --> 00:31:59,803
Dus dat is daar niet scalair.

34
00:32:00,263 --> 00:32:02,529
Scalaire subquery is dus gewoon 1 maal 1.

35
00:32:02,897 --> 00:32:03,269
ja.

36
00:32:03,460 --> 00:32:06,532
maar het gaat hier over
niet scalaire subqueries

37
00:32:06,563 --> 00:32:11,519
Subqueries waarvan we weten van die zijn niet scalair.

38
00:32:11,560 --> 00:32:14,093
 Jullie weten ook dat als we in de SELECT een subquery zetten...

39
00:32:14,706 --> 00:32:17,763
In de Select, ja dan mag daar maar 1 waarde komen.

40
00:32:18,137 --> 00:32:23,570
Als daar staat "SELECT klantnummer komma" en dan een subquery, daar mag maar 1 waarde uit komen.

41
00:32:23,684 --> 00:32:28,990
dat hoor daar te staan, dat is de enige manier dat je dat in de SELECT kan toevoegen, maar wat als dat nu niet...

42
00:32:29,430 --> 00:32:32,273
Dat dan meer dan 1 waarde is, hoe lossen we dat op?

43
00:32:33,830 --> 00:32:34,830
Oke

44
00:32:34,896 --> 00:32:35,896
Dus

45
00:32:36,296 --> 00:32:37,296
Dit Hier.

46
00:32:37,883 --> 00:32:39,163
Is geen probleem.

47
00:32:39,713 --> 00:32:41,646
Dit is een Scalaire subquery.

48
00:32:41,833 --> 00:32:45,023
He, ik zoek hier dingen op van reizen,...

49
00:32:45,544 --> 00:32:49,563
En ik schrijf een subquery in mijn SELECT en da maximum is 1 waarde.

50
00:32:49,820 --> 00:32:52,053
En het is een gecorelleerde subquery.

51
00:32:52,120 --> 00:32:53,253
Opzich geen probleem.

52
00:32:53,293 --> 00:32:58,366
is die nu gecorelleerd of niet, het belangrijkste is dat er hier maar 1 waarde uit komt waardoor dat dit perfect uitvoerd.

53
00:32:58,399 --> 00:33:03,773
Je moet altijdin het achterhoof houden, heeft dat dan de vorm van een tabel, is dat logisch?

54
00:33:04,460 --> 00:33:05,980
Dus dit is geen probleem, maar...

55
00:33:07,313 --> 00:33:08,806
Wat als ik dit nu zet?

56
00:33:09,313 --> 00:33:11,666
Dan krijg je inderdaad die foutmelding.

57
00:33:13,910 --> 00:33:17,090
Die verblijfsduur, dat kunnen meerdere verblijfsduren hier zijn.

58
00:33:17,160 --> 00:33:21,460
Voor dezelfde reis zij er waarschijnlijk meerdere bezoeken dus ook meerdere verblijfsduren.

59
00:33:21,970 --> 00:33:22,443
dus

60
00:33:22,896 --> 00:33:26,676
Hier komt reis 1 met 7 verschillende verbijfsduren.

61
00:33:26,693 --> 00:33:32,209
Nu kan je wel denken van ja, voor mij maakt dat dat logisch. Ik kan dat zoals die latteral terug gaan aanvullen. Maar zo werkt dat niet.

62
00:33:32,393 --> 00:33:35,061
De standard is niet zo gedefinieerd.

63
00:33:35,086 --> 00:33:37,539
Dus die verwacht daar altijd 1 waarde.

64
00:33:38,367 --> 00:33:40,100
Dus dan krijg je die fout.

65
00:33:40,780 --> 00:33:43,593
Dus hoe kunnen we dat oplossen? ook met die latteral weer.

66
00:33:43,967 --> 00:33:44,967
dus euh...

67
00:33:46,324 --> 00:33:48,223
Aja dit voorbeeldje kan ik ook nog geven.

68
00:33:54,700 --> 00:34:00,520
Het moet echt 1 maal 1 zijn voor subquery, want hier komt er maar 1tje uit, het zijn ook agregatiefuncties, komt 1 rijuit

69
00:34:00,620 --> 00:34:02,300
maar wel met 2 kolomen

70
00:34:02,327 --> 00:34:07,050
Dit zou je natuurlijk kunnen oplossen door dat op te splitsen in 2 gecorelleerde subqueries. 1tje voor som,

71
00:34:07,144 --> 00:34:08,744
1tje voor variantie.

72
00:34:09,494 --> 00:34:10,494
maar goed.

73
00:34:11,767 --> 00:34:14,026
Toon het maar voor de voledigheid voor de mensen die zich...

74
00:34:14,133 --> 00:34:16,667
Das een vraag die ik soms krijg.

75
00:34:16,680 --> 00:34:18,986
Dus de oplossing hier is lateral eh.

76
00:34:19,056 --> 00:34:20,576
Ja, we gaan onze...

77
00:34:20,616 --> 00:34:24,904
Hetgeen dat in onze SELECT stond gaan we verhuiszen naan onze FROM.

78
00:34:25,103 --> 00:34:26,936
We zeggen we willen al die reizen.

79
00:34:27,170 --> 00:34:33,042
Maar naast die reizen willen we ook per rijs een keer gaan kijken, hoe zit hethier met de verblijfsduur, zowel de som als de variantie.

80
00:34:33,174 --> 00:34:35,113
voor die reis, en ik voeg dat toe.

81
00:34:35,247 --> 00:34:37,120
en ik ga dat dan tonen.

82
00:34:37,480 --> 00:34:41,430
Het woordje lateral is hier nodig omdat verblijfsduur uit reizen komt.

83
00:34:42,484 --> 00:34:45,150
Uit de tabel reizen op een niveau hoger.

84
00:34:45,587 --> 00:34:46,587
oke

85
00:34:48,360 --> 00:34:51,027
Dus dan krijgenwe dit hier bijvoorbeeld.

86
00:34:51,150 --> 00:34:52,950
We krijgen hier variantie 0

87
00:34:53,060 --> 00:34:59,040
Ja, dat wilt zeggen dat er maar 1 bezoek is voor die reis. 31

88
00:34:59,746 --> 00:35:00,746
oke

89
00:35:06,947 --> 00:35:12,176
We zouden die query van daarnet ook zo kunnen schrijven, die eerste die ik daar gegevn had zonder die agregatie functies.

90
00:35:12,206 --> 00:35:14,690
Als we meerdere waarden hebben kunnen we datook zo doen.

91
00:35:15,813 --> 00:35:16,279
ja

92
00:35:16,787 --> 00:35:21,730
Nu dit zijn een beetje artificieele voorbeelden. want we kunnen dit natuurlijk ook gaan doen door...

93
00:35:21,990 --> 00:35:24,934
bezoeken op te schuiven naar een niveau hoger.

94
00:35:24,964 --> 00:35:27,097
en die dingen te gaan berekenen.

95
00:35:27,980 --> 00:35:28,980
oke

96
00:35:29,374 --> 00:35:32,174
We kunen combinaties maken van die dingen.

97
00:35:32,323 --> 00:35:34,956
Da wilt zeggen, je kan zowel...

98
00:35:36,050 --> 00:35:38,450
Werken met eenderzijds die latteral.

99
00:35:38,504 --> 00:35:44,333
We kunnen gaan werken met zelfs agregatiefuncties gecombineerd met een gewone waarde, dus die GROUP BY.

100
00:35:44,460 --> 00:35:46,713
Dus ge kunt eigenlijk redelijk veel van die dingen gaan doen.

101
00:35:48,307 --> 00:35:48,846
oke

102
00:35:52,437 --> 00:35:54,237
Dit is misschien nog eentje.

103
00:35:54,577 --> 00:35:56,177
Dat ik dan kan tonen.

104
00:35:56,540 --> 00:35:59,868
dus, jullie hebben al verschilende agregatiefuncties gezien,

105
00:36:01,290 --> 00:36:03,243
even terug gaan, ja

106
00:36:07,340 --> 00:36:08,340
moment

107
00:36:08,647 --> 00:36:11,247
Nu dat voorbeeldstaat er niemeer tussen, dat is niet erg

108
00:36:11,540 --> 00:36:14,659
Dus de COUNT kennen jullie allemaal.

109
00:36:14,913 --> 00:36:19,150
maar hetgeen wat we daarnet gedaan hebben met die UN NEST

110
00:36:19,470 --> 00:36:20,856
dus van een rij

111
00:36:21,360 --> 00:36:25,313
plat he, terug de oorspronkelijke waarde te gaan normaliseren.

112
00:36:25,493 --> 00:36:31,099
Kun je ook omgekeerd denormaliseren met een agregatiefucntie zoals array agregate, dus dan zetten we die samen

113
00:36:31,260 --> 00:36:34,160
Dus das ook een manier waarop je kan werken.

114
00:36:34,760 --> 00:36:38,408
Dus dan krijg je zoiets, het omgekeerde effect eigenlijk.

115
00:36:39,980 --> 00:36:45,046
Dan het meest voorkomende geval Denk ik, dus alle voorgaande gevallen die we tot nu toe gezien hebben

116
00:36:45,167 --> 00:36:49,136
Tenzij je echt met zo een normlisatie/denormalisatie probleem zit.

117
00:36:49,690 --> 00:36:54,329
Dus dat het gedenormaliseerde data is die je moet gaan normaliseren.

118
00:36:56,250 --> 00:37:00,826
De meeste queries die we tot nu toe gezien hebben kan je waarschijnlijk nog een ander alternatief vinden.

119
00:37:00,860 --> 00:37:02,873
Dat je die lateral niet nodig hebt, ja.

120
00:37:03,254 --> 00:37:09,250
Dit is eentje waardat je die lateral meestal, ja,.. je gaat er meestal niet rond kunnen.

121
00:37:09,706 --> 00:37:12,606
Dus, we hebben net de presentatie gezien van fetch first.

122
00:37:12,653 --> 00:37:15,753
Dus we willen dat gaan vergelijken met een beperkt afhankelijk resultaat.

123
00:37:16,100 --> 00:37:17,780
Dus wat wil dat zeggen?

124
00:37:18,366 --> 00:37:19,366
oke

125
00:37:20,460 --> 00:37:23,646
Dus,dit is zo een voorbeeldje? we hebben reizen...

126
00:37:24,616 --> 00:37:29,339
En we gaan dat joinen met deze subquery maar daar is een afhankelijkheid met die leteral.

127
00:37:29,687 --> 00:37:32,887
Dus probeer een keer te zien, wat doet deze query?

128
00:39:41,290 --> 00:39:45,106
Ah sorry, ik had even met het drinken mijn geluid af gezet.

129
00:39:45,233 --> 00:39:47,373
Goed dat Sasha dat meldt.

130
00:39:48,000 --> 00:39:52,076
Dus, de hint van Rik inderdaad,

131
00:39:52,636 --> 00:39:57,796
ofterwijl hetgeen dat Arthuur daar zegt ofterwijl Rik, het gaat over de 2 kleinste of de 2 grootste inderdaad.

132
00:39:58,506 --> 00:40:02,410
Dus als we het stapsgewijs doorlopen, we hebben hier de tabel reizen in de FROM.

133
00:40:02,970 --> 00:40:06,022
Alle reizen worden sowieso getoont, hier, LEFT.

134
00:40:06,800 --> 00:40:09,516
Dan word dat gecombineerd met eventueele bezoeken.

135
00:40:09,656 --> 00:40:12,262
Dat zie ik aan bezoeken B2

136
00:40:13,016 --> 00:40:15,516
En de WHERE conditie hier, het gaat voor deze reis.

137
00:40:16,647 --> 00:40:18,187
Dus de bezoeker van die reis.

138
00:40:19,173 --> 00:40:22,673
En voor het bezoeken ga ik opzoeken, welke hemelobjecten worden hier eigenlijk bezocht?

139
00:40:22,737 --> 00:40:26,310
En ik ga ze dan sorteren per diameter, alleen de eerste 2...

140
00:40:27,170 --> 00:40:29,076
tonen en ophalen.

141
00:40:29,204 --> 00:40:33,702
Dus dat wil eigenlijk zeggen, ik ga per reis alleen de eerste 2 objecten...

142
00:40:34,410 --> 00:40:36,433
Die bezocht worden volgens de diameter.

143
00:40:36,526 --> 00:40:40,066
Nu is de vraag natuurlijk hoe word dit gesorteed? ORDER BY diameter.

144
00:40:40,296 --> 00:40:42,469
Is dat van klein naar groot of van groot naar klein?

145
00:40:42,836 --> 00:40:49,770
Als je dat niet onthoudt, is niet erg, ik doe dat ook niet altijd mar dat is inderdaad het systeem dat hier wordt toegepast, we zullen eens kijken.

146
00:40:51,330 --> 00:40:51,830
oke

147
00:40:52,110 --> 00:40:55,770
Dus wat je hier ziet staan denk ik als je die diameters ziet oplopen.

148
00:40:55,943 --> 00:40:58,682
Je ziet hier, na een 32 gaat die er inderdaad over.

149
00:40:58,956 --> 00:41:02,969
Dus de 2 kleinse hemelobjecten per reis dat hier getoont worden

150
00:41:04,107 --> 00:41:05,107
oke

151
00:41:06,140 --> 00:41:06,720
goed

152
00:41:07,037 --> 00:41:10,590
Dus ter vergelijking, we gaan eens die opzoeken.

153
00:41:11,050 --> 00:41:13,009
Dit was lijn 32.

154
00:41:13,456 --> 00:41:18,256
Had ik reis nummer 32, had ik een object van diameter 7 en 14.

155
00:41:18,586 --> 00:41:21,199
Dus als ik alles bijvoorbeeld eens opzoek van 32

156
00:41:22,294 --> 00:41:26,420
vind ik daar inderdaad dus van 7, 14 en al die ander zijn groter.

157
00:41:26,680 --> 00:41:30,787
Dus ik krijg effectief de 2 kleinse objecten wat op die reis bezocht worden.

158
00:41:33,834 --> 00:41:34,834
oke

159
00:41:35,240 --> 00:41:42,180
Dus meestal kan je inderdaad zonder die lateral werken, maar sommige problemen kun je iderdaad moeilijk oplossen zonder die lateral.

160
00:41:42,247 --> 00:41:44,780
Dus als je met zo een voorbeeld zit...

161
00:41:46,413 --> 00:41:47,613
Zoals dit hier.

162
00:41:48,720 --> 00:41:52,933
Wanneer dat je eigenlijk een... het staat hier... moment...

163
00:41:53,370 --> 00:41:56,603
Als je moet vergelijken met een beperkt afhankelijk resultaat.

164
00:41:56,756 --> 00:41:59,902
Dus dat je eigenlijk bijvoorbeeld denkt, ik heb een subquery nodig.

165
00:42:00,143 --> 00:42:03,136
Waardat ik die fetch first nodig heb terwijl ik in een efhankelijkheid zit.

166
00:42:03,707 --> 00:42:06,823
Dan ga je 9/10 die lateral toch nodig hebben.

167
00:42:07,184 --> 00:42:11,919
Of je zit met dat voorbeeldje van daarstraks met die rij die je wilt gaan denormaliseren.

168
00:42:12,034 --> 00:42:14,434
Die je wilt gaan normaliseren sorry.

169
00:42:14,560 --> 00:42:19,799
Dan ga je 9/10 ook zo een lateral nodig hebben alhoewel dat daar soms wel alternatieven voor nodig zijn.

170
00:42:20,113 --> 00:42:23,802
Voor de rest kan je eigenlijk vaak alternatieve queries schrijven.

171
00:42:24,603 --> 00:42:27,186
Dan is alleen de vraag, als je die queries schrijft...

172
00:42:28,626 --> 00:42:31,293
Als je weet hoe dat je dat dan kan doen.

173
00:42:31,886 --> 00:42:39,062
Ik heb die manier met lateral, ik heb die manier zonder lateral , we gaan die kostprijzen vergelijken om tezien van, welke query kies ik hier nu natuurlijk?

174
00:42:39,090 --> 00:42:40,090
Dat proberen we jullie..

175
00:42:40,413 --> 00:42:45,786
dus perfomantie is iets, eenkeer dat je databanken beheerst, dan kom je echt wel in dat gebied van performantie.

176
00:42:46,530 --> 00:42:47,530
oke

177
00:42:47,710 --> 00:42:50,177
Zijn er nog vragen over die lateral?

178
00:42:51,526 --> 00:42:52,646
Lateral joins.

179
00:43:04,480 --> 00:43:05,480
oke

